
C:\Users\kevin\AppData\Local\Temp\arduino_build_909104/mark2_attiny1614.ino.ino.elf:     file format elf32-avr


Disassembly of section .text:

00000200 <__vectors>:
__vectors():
../../../../crt1/gcrt1.S:61
     200:	0c 94 3f 01 	jmp	0x27e	; 0x27e <__ctors_end>
../../../../crt1/gcrt1.S:67
     204:	0c 94 5c 01 	jmp	0x2b8	; 0x2b8 <__bad_interrupt>
../../../../crt1/gcrt1.S:68
     208:	0c 94 5c 01 	jmp	0x2b8	; 0x2b8 <__bad_interrupt>
../../../../crt1/gcrt1.S:69
     20c:	0c 94 5c 01 	jmp	0x2b8	; 0x2b8 <__bad_interrupt>
../../../../crt1/gcrt1.S:70
     210:	0c 94 5c 01 	jmp	0x2b8	; 0x2b8 <__bad_interrupt>
../../../../crt1/gcrt1.S:71
     214:	0c 94 5c 01 	jmp	0x2b8	; 0x2b8 <__bad_interrupt>
../../../../crt1/gcrt1.S:72
     218:	0c 94 5c 01 	jmp	0x2b8	; 0x2b8 <__bad_interrupt>
../../../../crt1/gcrt1.S:73
     21c:	0c 94 5c 01 	jmp	0x2b8	; 0x2b8 <__bad_interrupt>
../../../../crt1/gcrt1.S:74
     220:	0c 94 5c 01 	jmp	0x2b8	; 0x2b8 <__bad_interrupt>
../../../../crt1/gcrt1.S:75
     224:	0c 94 5c 01 	jmp	0x2b8	; 0x2b8 <__bad_interrupt>
../../../../crt1/gcrt1.S:76
     228:	0c 94 5c 01 	jmp	0x2b8	; 0x2b8 <__bad_interrupt>
../../../../crt1/gcrt1.S:77
     22c:	0c 94 5c 01 	jmp	0x2b8	; 0x2b8 <__bad_interrupt>
../../../../crt1/gcrt1.S:78
     230:	0c 94 5c 01 	jmp	0x2b8	; 0x2b8 <__bad_interrupt>
../../../../crt1/gcrt1.S:79
     234:	0c 94 5c 01 	jmp	0x2b8	; 0x2b8 <__bad_interrupt>
../../../../crt1/gcrt1.S:80
     238:	0c 94 5c 01 	jmp	0x2b8	; 0x2b8 <__bad_interrupt>
../../../../crt1/gcrt1.S:81
     23c:	0c 94 71 07 	jmp	0xee2	; 0xee2 <__vector_15>
../../../../crt1/gcrt1.S:82
     240:	0c 94 5c 01 	jmp	0x2b8	; 0x2b8 <__bad_interrupt>
../../../../crt1/gcrt1.S:83
     244:	0c 94 5c 01 	jmp	0x2b8	; 0x2b8 <__bad_interrupt>
../../../../crt1/gcrt1.S:84
     248:	0c 94 5c 01 	jmp	0x2b8	; 0x2b8 <__bad_interrupt>
../../../../crt1/gcrt1.S:85
     24c:	0c 94 5c 01 	jmp	0x2b8	; 0x2b8 <__bad_interrupt>
../../../../crt1/gcrt1.S:86
     250:	0c 94 5c 01 	jmp	0x2b8	; 0x2b8 <__bad_interrupt>
../../../../crt1/gcrt1.S:87
     254:	0c 94 5c 01 	jmp	0x2b8	; 0x2b8 <__bad_interrupt>
../../../../crt1/gcrt1.S:88
     258:	0c 94 5c 01 	jmp	0x2b8	; 0x2b8 <__bad_interrupt>
../../../../crt1/gcrt1.S:89
     25c:	0c 94 5c 01 	jmp	0x2b8	; 0x2b8 <__bad_interrupt>
../../../../crt1/gcrt1.S:90
     260:	0c 94 c7 07 	jmp	0xf8e	; 0xf8e <__vector_24>
../../../../crt1/gcrt1.S:91
     264:	0c 94 78 08 	jmp	0x10f0	; 0x10f0 <__vector_25>
../../../../crt1/gcrt1.S:92
     268:	0c 94 5c 01 	jmp	0x2b8	; 0x2b8 <__bad_interrupt>
../../../../crt1/gcrt1.S:93
     26c:	0c 94 43 07 	jmp	0xe86	; 0xe86 <__vector_27>
../../../../crt1/gcrt1.S:94
     270:	0c 94 1d 07 	jmp	0xe3a	; 0xe3a <__vector_28>
../../../../crt1/gcrt1.S:95
     274:	0c 94 5c 01 	jmp	0x2b8	; 0x2b8 <__bad_interrupt>
../../../../crt1/gcrt1.S:96
     278:	0c 94 5c 01 	jmp	0x2b8	; 0x2b8 <__bad_interrupt>

0000027c <__ctors_start>:
__trampolines_start():
     27c:	22 09       	sbc	r18, r2

0000027e <__ctors_end>:
__dtors_end():
../../../../crt1/gcrt1.S:230
     27e:	11 24       	eor	r1, r1
../../../../crt1/gcrt1.S:231
     280:	1f be       	out	0x3f, r1	; 63
../../../../crt1/gcrt1.S:232
     282:	cf ef       	ldi	r28, 0xFF	; 255
../../../../crt1/gcrt1.S:234
     284:	cd bf       	out	0x3d, r28	; 61
../../../../crt1/gcrt1.S:236
     286:	df e3       	ldi	r29, 0x3F	; 63
../../../../crt1/gcrt1.S:237
     288:	de bf       	out	0x3e, r29	; 62

0000028a <__do_clear_bss>:
__do_clear_bss():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2441
     28a:	2a e3       	ldi	r18, 0x3A	; 58
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2442
     28c:	a0 e0       	ldi	r26, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2443
     28e:	b8 e3       	ldi	r27, 0x38	; 56
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2444
     290:	01 c0       	rjmp	.+2      	; 0x294 <.do_clear_bss_start>

00000292 <.do_clear_bss_loop>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2446
     292:	1d 92       	st	X+, r1

00000294 <.do_clear_bss_start>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2448
     294:	a0 36       	cpi	r26, 0x60	; 96
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2449
     296:	b2 07       	cpc	r27, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2450
     298:	e1 f7       	brne	.-8      	; 0x292 <.do_clear_bss_loop>

0000029a <__do_global_ctors>:
__do_global_ctors():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2466
     29a:	11 e0       	ldi	r17, 0x01	; 1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2467
     29c:	cf e3       	ldi	r28, 0x3F	; 63
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2468
     29e:	d1 e0       	ldi	r29, 0x01	; 1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2472
     2a0:	04 c0       	rjmp	.+8      	; 0x2aa <__do_global_ctors+0x10>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2474
     2a2:	21 97       	sbiw	r28, 0x01	; 1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2480
     2a4:	fe 01       	movw	r30, r28
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2481
     2a6:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <__tablejump2__>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2483
     2aa:	ce 33       	cpi	r28, 0x3E	; 62
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2484
     2ac:	d1 07       	cpc	r29, r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2489
     2ae:	c9 f7       	brne	.-14     	; 0x2a2 <__do_global_ctors+0x8>
../../../../crt1/gcrt1.S:314
     2b0:	0e 94 75 09 	call	0x12ea	; 0x12ea <main>
../../../../crt1/gcrt1.S:315
     2b4:	0c 94 01 0d 	jmp	0x1a02	; 0x1a02 <_exit>

000002b8 <__bad_interrupt>:
__vector_22():
../../../../crt1/gcrt1.S:209
     2b8:	0c 94 00 01 	jmp	0x200	; 0x200 <__vectors>

000002bc <tinyNeoPixel::setPixelColor(unsigned int, unsigned long) [clone .constprop.6]>:
_ZN12tinyNeoPixel13setPixelColorEjm.constprop.6():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.cpp:876
    p[bOffset] = b;
  }
}

// Set pixel color from 'packed' 32-bit RGB color:
void tinyNeoPixel::setPixelColor(uint16_t n, uint32_t c) {
     2bc:	8f 92       	push	r8
     2be:	9f 92       	push	r9
     2c0:	af 92       	push	r10
     2c2:	bf 92       	push	r11
     2c4:	cf 92       	push	r12
     2c6:	df 92       	push	r13
     2c8:	ef 92       	push	r14
     2ca:	ff 92       	push	r15
     2cc:	cf 93       	push	r28
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.cpp:877
  if (n < numLEDs) {
     2ce:	20 91 4d 3a 	lds	r18, 0x3A4D	; 0x803a4d <strip>
     2d2:	30 91 4e 3a 	lds	r19, 0x3A4E	; 0x803a4e <strip+0x1>
     2d6:	82 17       	cp	r24, r18
     2d8:	93 07       	cpc	r25, r19
     2da:	e8 f5       	brcc	.+122    	; 0x356 <tinyNeoPixel::setPixelColor(unsigned int, unsigned long) [clone .constprop.6]+0x9a>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.cpp:879
    uint8_t *p,
            r = (uint8_t)(c >> 16),
     2dc:	4b 01       	movw	r8, r22
     2de:	aa 24       	eor	r10, r10
     2e0:	bb 24       	eor	r11, r11
     2e2:	c8 2d       	mov	r28, r8
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.cpp:880
            g = (uint8_t)(c >>  8),
     2e4:	c5 2e       	mov	r12, r21
     2e6:	d6 2e       	mov	r13, r22
     2e8:	e7 2e       	mov	r14, r23
     2ea:	ff 24       	eor	r15, r15
     2ec:	bc 2d       	mov	r27, r12
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.cpp:881
            b = (uint8_t)c;
     2ee:	a4 2f       	mov	r26, r20
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.cpp:882
    if (brightness) { // See notes in setBrightness()
     2f0:	20 91 52 3a 	lds	r18, 0x3A52	; 0x803a52 <strip+0x5>
     2f4:	22 23       	and	r18, r18
     2f6:	61 f0       	breq	.+24     	; 0x310 <tinyNeoPixel::setPixelColor(unsigned int, unsigned long) [clone .constprop.6]+0x54>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.cpp:883
      r = (r * brightness) >> 8;
     2f8:	82 9e       	mul	r8, r18
     2fa:	40 01       	movw	r8, r0
     2fc:	11 24       	eor	r1, r1
     2fe:	c9 2d       	mov	r28, r9
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.cpp:884
      g = (g * brightness) >> 8;
     300:	2c 9d       	mul	r18, r12
     302:	60 01       	movw	r12, r0
     304:	11 24       	eor	r1, r1
     306:	bd 2d       	mov	r27, r13
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.cpp:885
      b = (b * brightness) >> 8;
     308:	24 9f       	mul	r18, r20
     30a:	f0 01       	movw	r30, r0
     30c:	11 24       	eor	r1, r1
     30e:	af 2f       	mov	r26, r31
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.cpp:887
    }
    if (wOffset == rOffset) {
     310:	e0 91 58 3a 	lds	r30, 0x3A58	; 0x803a58 <strip+0xb>
     314:	e0 90 53 3a 	lds	r14, 0x3A53	; 0x803a53 <strip+0x6>
     318:	f0 90 54 3a 	lds	r15, 0x3A54	; 0x803a54 <strip+0x7>
     31c:	30 91 55 3a 	lds	r19, 0x3A55	; 0x803a55 <strip+0x8>
     320:	e3 13       	cpse	r30, r19
     322:	23 c0       	rjmp	.+70     	; 0x36a <tinyNeoPixel::setPixelColor(unsigned int, unsigned long) [clone .constprop.6]+0xae>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.cpp:888
      p = &pixels[n * 3];
     324:	9c 01       	movw	r18, r24
     326:	22 0f       	add	r18, r18
     328:	33 1f       	adc	r19, r19
     32a:	82 0f       	add	r24, r18
     32c:	93 1f       	adc	r25, r19
     32e:	8e 0d       	add	r24, r14
     330:	9f 1d       	adc	r25, r15
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.cpp:894
    } else {
      p = &pixels[n * 4];
      uint8_t w = (uint8_t)(c >> 24);
      p[wOffset] = brightness ? ((w * brightness) >> 8) : w;
    }
    p[rOffset] = r;
     332:	e0 91 55 3a 	lds	r30, 0x3A55	; 0x803a55 <strip+0x8>
     336:	e8 0f       	add	r30, r24
     338:	f9 2f       	mov	r31, r25
     33a:	f1 1d       	adc	r31, r1
     33c:	c0 83       	st	Z, r28
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.cpp:895
    p[gOffset] = g;
     33e:	e0 91 56 3a 	lds	r30, 0x3A56	; 0x803a56 <strip+0x9>
     342:	e8 0f       	add	r30, r24
     344:	f9 2f       	mov	r31, r25
     346:	f1 1d       	adc	r31, r1
     348:	b0 83       	st	Z, r27
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.cpp:896
    p[bOffset] = b;
     34a:	20 91 57 3a 	lds	r18, 0x3A57	; 0x803a57 <strip+0xa>
     34e:	82 0f       	add	r24, r18
     350:	91 1d       	adc	r25, r1
     352:	fc 01       	movw	r30, r24
     354:	a0 83       	st	Z, r26
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.cpp:898
  }
}
     356:	cf 91       	pop	r28
     358:	ff 90       	pop	r15
     35a:	ef 90       	pop	r14
     35c:	df 90       	pop	r13
     35e:	cf 90       	pop	r12
     360:	bf 90       	pop	r11
     362:	af 90       	pop	r10
     364:	9f 90       	pop	r9
     366:	8f 90       	pop	r8
     368:	08 95       	ret
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.cpp:890
      b = (b * brightness) >> 8;
    }
    if (wOffset == rOffset) {
      p = &pixels[n * 3];
    } else {
      p = &pixels[n * 4];
     36a:	88 0f       	add	r24, r24
     36c:	99 1f       	adc	r25, r25
     36e:	88 0f       	add	r24, r24
     370:	99 1f       	adc	r25, r25
     372:	8e 0d       	add	r24, r14
     374:	9f 1d       	adc	r25, r15
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.cpp:891
      uint8_t w = (uint8_t)(c >> 24);
     376:	47 2f       	mov	r20, r23
     378:	55 27       	eor	r21, r21
     37a:	66 27       	eor	r22, r22
     37c:	77 27       	eor	r23, r23
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.cpp:892
      p[wOffset] = brightness ? ((w * brightness) >> 8) : w;
     37e:	22 23       	and	r18, r18
     380:	49 f0       	breq	.+18     	; 0x394 <tinyNeoPixel::setPixelColor(unsigned int, unsigned long) [clone .constprop.6]+0xd8>
     382:	30 e0       	ldi	r19, 0x00	; 0
     384:	24 9f       	mul	r18, r20
     386:	70 01       	movw	r14, r0
     388:	25 9f       	mul	r18, r21
     38a:	f0 0c       	add	r15, r0
     38c:	34 9f       	mul	r19, r20
     38e:	f0 0c       	add	r15, r0
     390:	11 24       	eor	r1, r1
     392:	4f 2d       	mov	r20, r15
     394:	e8 0f       	add	r30, r24
     396:	f9 2f       	mov	r31, r25
     398:	f1 1d       	adc	r31, r1
     39a:	40 83       	st	Z, r20
     39c:	ca cf       	rjmp	.-108    	; 0x332 <tinyNeoPixel::setPixelColor(unsigned int, unsigned long) [clone .constprop.6]+0x76>

0000039e <UartClass::availableForWrite()>:
_ZN9UartClass17availableForWriteEv():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:323
int UartClass::availableForWrite(void) {
  tx_buffer_index_t head;
  tx_buffer_index_t tail;

  TX_BUFFER_ATOMIC {
    head = _tx_buffer_head;
     39e:	fc 01       	movw	r30, r24
     3a0:	50 8d       	ldd	r21, Z+24	; 0x18
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:324
    tail = _tx_buffer_tail;
     3a2:	41 8d       	ldd	r20, Z+25	; 0x19
     3a4:	25 2f       	mov	r18, r21
     3a6:	30 e0       	ldi	r19, 0x00	; 0
     3a8:	84 2f       	mov	r24, r20
     3aa:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:327
  }
  if (head >= tail) {
    return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
     3ac:	82 1b       	sub	r24, r18
     3ae:	93 0b       	sbc	r25, r19
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:326

  TX_BUFFER_ATOMIC {
    head = _tx_buffer_head;
    tail = _tx_buffer_tail;
  }
  if (head >= tail) {
     3b0:	54 17       	cp	r21, r20
     3b2:	10 f0       	brcs	.+4      	; 0x3b8 <UartClass::availableForWrite()+0x1a>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:327
    return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
     3b4:	cf 96       	adiw	r24, 0x3f	; 63
     3b6:	08 95       	ret
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:329
  }
  return tail - head - 1;
     3b8:	01 97       	sbiw	r24, 0x01	; 1
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:330
}
     3ba:	08 95       	ret

000003bc <UartClass::read()>:
_ZN9UartClass4readEv():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:307
  } else {
    return _rx_buffer[_rx_buffer_tail];
  }
}

int UartClass::read(void) {
     3bc:	fc 01       	movw	r30, r24
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:309
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
     3be:	96 89       	ldd	r25, Z+22	; 0x16
     3c0:	87 89       	ldd	r24, Z+23	; 0x17
     3c2:	98 17       	cp	r25, r24
     3c4:	61 f0       	breq	.+24     	; 0x3de <UartClass::read()+0x22>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:312
    return -1;
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
     3c6:	a7 89       	ldd	r26, Z+23	; 0x17
     3c8:	ae 0f       	add	r26, r30
     3ca:	bf 2f       	mov	r27, r31
     3cc:	b1 1d       	adc	r27, r1
     3ce:	5b 96       	adiw	r26, 0x1b	; 27
     3d0:	8c 91       	ld	r24, X
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:313
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) & (SERIAL_RX_BUFFER_SIZE-1); // % SERIAL_RX_BUFFER_SIZE;
     3d2:	97 89       	ldd	r25, Z+23	; 0x17
     3d4:	9f 5f       	subi	r25, 0xFF	; 255
     3d6:	9f 73       	andi	r25, 0x3F	; 63
     3d8:	97 8b       	std	Z+23, r25	; 0x17
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:314
    return c;
     3da:	90 e0       	ldi	r25, 0x00	; 0
     3dc:	08 95       	ret
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:310
}

int UartClass::read(void) {
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
     3de:	8f ef       	ldi	r24, 0xFF	; 255
     3e0:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:316
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) & (SERIAL_RX_BUFFER_SIZE-1); // % SERIAL_RX_BUFFER_SIZE;
    return c;
  }
}
     3e2:	08 95       	ret

000003e4 <UartClass::peek()>:
_ZN9UartClass4peekEv():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:299

int UartClass::available(void) {
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) & (SERIAL_RX_BUFFER_SIZE-1); //% SERIAL_RX_BUFFER_SIZE;
}

int UartClass::peek(void) {
     3e4:	fc 01       	movw	r30, r24
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:300
  if (_rx_buffer_head == _rx_buffer_tail) {
     3e6:	96 89       	ldd	r25, Z+22	; 0x16
     3e8:	87 89       	ldd	r24, Z+23	; 0x17
     3ea:	98 17       	cp	r25, r24
     3ec:	31 f0       	breq	.+12     	; 0x3fa <UartClass::peek()+0x16>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:303
    return -1;
  } else {
    return _rx_buffer[_rx_buffer_tail];
     3ee:	87 89       	ldd	r24, Z+23	; 0x17
     3f0:	e8 0f       	add	r30, r24
     3f2:	f1 1d       	adc	r31, r1
     3f4:	83 8d       	ldd	r24, Z+27	; 0x1b
     3f6:	90 e0       	ldi	r25, 0x00	; 0
     3f8:	08 95       	ret
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:301
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) & (SERIAL_RX_BUFFER_SIZE-1); //% SERIAL_RX_BUFFER_SIZE;
}

int UartClass::peek(void) {
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
     3fa:	8f ef       	ldi	r24, 0xFF	; 255
     3fc:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:305
  } else {
    return _rx_buffer[_rx_buffer_tail];
  }
}
     3fe:	08 95       	ret

00000400 <UartClass::available()>:
_ZN9UartClass9availableEv():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:295

  // Note: Does not change output pins
  _written = false;
}

int UartClass::available(void) {
     400:	fc 01       	movw	r30, r24
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:296
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) & (SERIAL_RX_BUFFER_SIZE-1); //% SERIAL_RX_BUFFER_SIZE;
     402:	96 89       	ldd	r25, Z+22	; 0x16
     404:	27 89       	ldd	r18, Z+23	; 0x17
     406:	89 2f       	mov	r24, r25
     408:	90 e0       	ldi	r25, 0x00	; 0
     40a:	80 5c       	subi	r24, 0xC0	; 192
     40c:	9f 4f       	sbci	r25, 0xFF	; 255
     40e:	82 1b       	sub	r24, r18
     410:	91 09       	sbc	r25, r1
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:297
}
     412:	8f 73       	andi	r24, 0x3F	; 63
     414:	99 27       	eor	r25, r25
     416:	08 95       	ret

00000418 <UartClass::end()>:
_ZN9UartClass3endEv():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:279

  // Restore SREG content
  SREG = oldSREG;
}

void UartClass::end() {
     418:	cf 93       	push	r28
     41a:	df 93       	push	r29
     41c:	ec 01       	movw	r28, r24
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:281
  // wait for transmission of outgoing data
  flush();
     41e:	e8 81       	ld	r30, Y
     420:	f9 81       	ldd	r31, Y+1	; 0x01
     422:	02 84       	ldd	r0, Z+10	; 0x0a
     424:	f3 85       	ldd	r31, Z+11	; 0x0b
     426:	e0 2d       	mov	r30, r0
     428:	09 95       	icall
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:285

  // Disable receiver and transmitter as well as the RX complete and
  // data register empty interrupts.
  (*_hwserial_module).CTRLB &= ~(USART_RXEN_bm | USART_TXEN_bm);
     42a:	ec 85       	ldd	r30, Y+12	; 0x0c
     42c:	fd 85       	ldd	r31, Y+13	; 0x0d
     42e:	86 81       	ldd	r24, Z+6	; 0x06
     430:	8f 73       	andi	r24, 0x3F	; 63
     432:	86 83       	std	Z+6, r24	; 0x06
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:286
  (*_hwserial_module).CTRLA &= ~(USART_RXCIE_bm | USART_DREIE_bm);
     434:	ec 85       	ldd	r30, Y+12	; 0x0c
     436:	fd 85       	ldd	r31, Y+13	; 0x0d
     438:	85 81       	ldd	r24, Z+5	; 0x05
     43a:	8f 75       	andi	r24, 0x5F	; 95
     43c:	85 83       	std	Z+5, r24	; 0x05
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:289

  // clear any received data
  _rx_buffer_head = _rx_buffer_tail;
     43e:	8f 89       	ldd	r24, Y+23	; 0x17
     440:	8e 8b       	std	Y+22, r24	; 0x16
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:292

  // Note: Does not change output pins
  _written = false;
     442:	1d 8a       	std	Y+21, r1	; 0x15
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:293
}
     444:	df 91       	pop	r29
     446:	cf 91       	pop	r28
     448:	08 95       	ret

0000044a <UartClass::_tx_data_empty_irq()>:
_ZN9UartClass18_tx_data_empty_irqEv():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:96
  #define TX_BUFFER_ATOMIC
#endif

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void UartClass::_tx_data_empty_irq(void) {
     44a:	cf 93       	push	r28
     44c:	df 93       	push	r29
     44e:	fc 01       	movw	r30, r24
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:98
  // Check if tx buffer already empty.
  if (_tx_buffer_head == _tx_buffer_tail) {
     450:	90 8d       	ldd	r25, Z+24	; 0x18
     452:	81 8d       	ldd	r24, Z+25	; 0x19
     454:	c4 85       	ldd	r28, Z+12	; 0x0c
     456:	d5 85       	ldd	r29, Z+13	; 0x0d
     458:	98 13       	cpse	r25, r24
     45a:	06 c0       	rjmp	.+12     	; 0x468 <UartClass::_tx_data_empty_irq()+0x1e>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:100
    // Buffer empty, so disable "data register empty" interrupt
    (*_hwserial_module).CTRLA &= (~USART_DREIE_bm);
     45c:	8d 81       	ldd	r24, Y+5	; 0x05
     45e:	8f 7d       	andi	r24, 0xDF	; 223
     460:	8d 83       	std	Y+5, r24	; 0x05
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:120

  if (_tx_buffer_head == _tx_buffer_tail) {
    // Buffer empty, so disable "data register empty" interrupt
    (*_hwserial_module).CTRLA &= (~USART_DREIE_bm);
  }
}
     462:	df 91       	pop	r29
     464:	cf 91       	pop	r28
     466:	08 95       	ret
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:106
    return;
  }

  // There must be more data in the output
  // buffer. Send the next byte
  unsigned char c = _tx_buffer[_tx_buffer_tail];
     468:	a1 8d       	ldd	r26, Z+25	; 0x19
     46a:	ae 0f       	add	r26, r30
     46c:	bf 2f       	mov	r27, r31
     46e:	b1 1d       	adc	r27, r1
     470:	a5 5a       	subi	r26, 0xA5	; 165
     472:	bf 4f       	sbci	r27, 0xFF	; 255
     474:	9c 91       	ld	r25, X
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:107
  _tx_buffer_tail = (_tx_buffer_tail + 1) & (SERIAL_TX_BUFFER_SIZE-1); //% SERIAL_TX_BUFFER_SIZE;
     476:	81 8d       	ldd	r24, Z+25	; 0x19
     478:	8f 5f       	subi	r24, 0xFF	; 255
     47a:	8f 73       	andi	r24, 0x3F	; 63
     47c:	81 8f       	std	Z+25, r24	; 0x19
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:112

  // clear the TXCIF flag -- "can be cleared by writing a one to its bit
  // location". This makes sure flush() won't return until the bytes
  // actually got written
  (*_hwserial_module).STATUS = USART_TXCIF_bm;
     47e:	80 e4       	ldi	r24, 0x40	; 64
     480:	8c 83       	std	Y+4, r24	; 0x04
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:114

  (*_hwserial_module).TXDATAL = c;
     482:	a4 85       	ldd	r26, Z+12	; 0x0c
     484:	b5 85       	ldd	r27, Z+13	; 0x0d
     486:	12 96       	adiw	r26, 0x02	; 2
     488:	9c 93       	st	X, r25
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:116

  if (_tx_buffer_head == _tx_buffer_tail) {
     48a:	90 8d       	ldd	r25, Z+24	; 0x18
     48c:	81 8d       	ldd	r24, Z+25	; 0x19
     48e:	98 13       	cpse	r25, r24
     490:	e8 cf       	rjmp	.-48     	; 0x462 <UartClass::_tx_data_empty_irq()+0x18>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:118
    // Buffer empty, so disable "data register empty" interrupt
    (*_hwserial_module).CTRLA &= (~USART_DREIE_bm);
     492:	04 84       	ldd	r0, Z+12	; 0x0c
     494:	f5 85       	ldd	r31, Z+13	; 0x0d
     496:	e0 2d       	mov	r30, r0
     498:	85 81       	ldd	r24, Z+5	; 0x05
     49a:	8f 7d       	andi	r24, 0xDF	; 223
     49c:	85 83       	std	Z+5, r24	; 0x05
     49e:	e1 cf       	rjmp	.-62     	; 0x462 <UartClass::_tx_data_empty_irq()+0x18>

000004a0 <UartClass::_poll_tx_data_empty()>:
_ZN9UartClass19_poll_tx_data_emptyEv():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:123
  }
}

// To invoke data empty "interrupt" via a call, use this method
void UartClass::_poll_tx_data_empty(void) {
     4a0:	dc 01       	movw	r26, r24
     4a2:	1c 96       	adiw	r26, 0x0c	; 12
     4a4:	ed 91       	ld	r30, X+
     4a6:	fc 91       	ld	r31, X
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:124
  if ((!(SREG & CPU_I_bm)) || (!((*_hwserial_module).CTRLA & USART_DREIE_bm)) || CPUINT.STATUS) {
     4a8:	0f b6       	in	r0, 0x3f	; 63
     4aa:	07 fe       	sbrs	r0, 7
     4ac:	07 c0       	rjmp	.+14     	; 0x4bc <UartClass::_poll_tx_data_empty()+0x1c>
     4ae:	25 81       	ldd	r18, Z+5	; 0x05
     4b0:	25 ff       	sbrs	r18, 5
     4b2:	04 c0       	rjmp	.+8      	; 0x4bc <UartClass::_poll_tx_data_empty()+0x1c>
     4b4:	20 91 11 01 	lds	r18, 0x0111	; 0x800111 <digital_pin_to_port+0x7f66bd>
     4b8:	22 23       	and	r18, r18
     4ba:	21 f0       	breq	.+8      	; 0x4c4 <UartClass::_poll_tx_data_empty()+0x24>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:137
    // so we'll have to poll the "data register empty" flag ourselves.
    // If it is set, pretend an interrupt has happened and call the handler
    // to free up space for us.

    // Invoke interrupt handler only if conditions data register is empty
    if ((*_hwserial_module).STATUS & USART_DREIF_bm) {
     4bc:	24 81       	ldd	r18, Z+4	; 0x04
     4be:	25 fd       	sbrc	r18, 5
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:138
      _tx_data_empty_irq();
     4c0:	0c 94 25 02 	jmp	0x44a	; 0x44a <UartClass::_tx_data_empty_irq()>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:142
    }
  }
  // In case interrupts are enabled, the interrupt routine will be invoked by itself
}
     4c4:	08 95       	ret

000004c6 <UartClass::write(unsigned char)>:
_ZN9UartClass5writeEh():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:361
  }
  // When we get here, nothing is queued anymore (DREIE is disabled) and
  // the hardware finished transmission (TXCIF is set).
}

size_t UartClass::write(uint8_t c) {
     4c6:	0f 93       	push	r16
     4c8:	1f 93       	push	r17
     4ca:	cf 93       	push	r28
     4cc:	df 93       	push	r29
     4ce:	ec 01       	movw	r28, r24
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:362
  _written = true;
     4d0:	81 e0       	ldi	r24, 0x01	; 1
     4d2:	8d 8b       	std	Y+21, r24	; 0x15
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:368

  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective data rate at high (>
  // 500kbit/s) bit rates, where interrupt overhead becomes a slowdown.
  if ((_tx_buffer_head == _tx_buffer_tail) && ((*_hwserial_module).STATUS & USART_DREIF_bm)) {
     4d4:	98 8d       	ldd	r25, Y+24	; 0x18
     4d6:	89 8d       	ldd	r24, Y+25	; 0x19
     4d8:	98 13       	cpse	r25, r24
     4da:	16 c0       	rjmp	.+44     	; 0x508 <UartClass::write(unsigned char)+0x42>
     4dc:	ec 85       	ldd	r30, Y+12	; 0x0c
     4de:	fd 85       	ldd	r31, Y+13	; 0x0d
     4e0:	84 81       	ldd	r24, Z+4	; 0x04
     4e2:	85 ff       	sbrs	r24, 5
     4e4:	11 c0       	rjmp	.+34     	; 0x508 <UartClass::write(unsigned char)+0x42>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:369
    (*_hwserial_module).TXDATAL = c;
     4e6:	62 83       	std	Z+2, r22	; 0x02
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:370
    (*_hwserial_module).STATUS = USART_TXCIF_bm;
     4e8:	ec 85       	ldd	r30, Y+12	; 0x0c
     4ea:	fd 85       	ldd	r31, Y+13	; 0x0d
     4ec:	80 e4       	ldi	r24, 0x40	; 64
     4ee:	84 83       	std	Z+4, r24	; 0x04
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:374

    // Make sure data register empty interrupt is disabled to avoid
    // that the interrupt handler is called in this situation
    (*_hwserial_module).CTRLA &= (~USART_DREIE_bm);
     4f0:	ec 85       	ldd	r30, Y+12	; 0x0c
     4f2:	fd 85       	ldd	r31, Y+13	; 0x0d
     4f4:	85 81       	ldd	r24, Z+5	; 0x05
     4f6:	8f 7d       	andi	r24, 0xDF	; 223
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:391

  _tx_buffer[_tx_buffer_head] = c;
  _tx_buffer_head = i;

  // Enable data "register empty interrupt"
  (*_hwserial_module).CTRLA |= USART_DREIE_bm;
     4f8:	85 83       	std	Z+5, r24	; 0x05
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:394

  return 1;
}
     4fa:	81 e0       	ldi	r24, 0x01	; 1
     4fc:	90 e0       	ldi	r25, 0x00	; 0
     4fe:	df 91       	pop	r29
     500:	cf 91       	pop	r28
     502:	1f 91       	pop	r17
     504:	0f 91       	pop	r16
     506:	08 95       	ret
     508:	06 2f       	mov	r16, r22
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:379
    (*_hwserial_module).CTRLA &= (~USART_DREIE_bm);

    return 1;
  }

  tx_buffer_index_t i = (_tx_buffer_head + 1) & (SERIAL_TX_BUFFER_SIZE-1); // % SERIAL_TX_BUFFER_SIZE;
     50a:	18 8d       	ldd	r17, Y+24	; 0x18
     50c:	1f 5f       	subi	r17, 0xFF	; 255
     50e:	1f 73       	andi	r17, 0x3F	; 63
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:383

  //If the output buffer is full, there's nothing for it other than to
  //wait for the interrupt handler to empty it a bit (or emulate interrupts)
  while (i == _tx_buffer_tail) {
     510:	89 8d       	ldd	r24, Y+25	; 0x19
     512:	81 13       	cpse	r24, r17
     514:	04 c0       	rjmp	.+8      	; 0x51e <UartClass::write(unsigned char)+0x58>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:384
    _poll_tx_data_empty();
     516:	ce 01       	movw	r24, r28
     518:	0e 94 50 02 	call	0x4a0	; 0x4a0 <UartClass::_poll_tx_data_empty()>
     51c:	f9 cf       	rjmp	.-14     	; 0x510 <UartClass::write(unsigned char)+0x4a>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:387
  }

  _tx_buffer[_tx_buffer_head] = c;
     51e:	e8 8d       	ldd	r30, Y+24	; 0x18
     520:	ec 0f       	add	r30, r28
     522:	fd 2f       	mov	r31, r29
     524:	f1 1d       	adc	r31, r1
     526:	e5 5a       	subi	r30, 0xA5	; 165
     528:	ff 4f       	sbci	r31, 0xFF	; 255
     52a:	00 83       	st	Z, r16
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:388
  _tx_buffer_head = i;
     52c:	18 8f       	std	Y+24, r17	; 0x18
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:391

  // Enable data "register empty interrupt"
  (*_hwserial_module).CTRLA |= USART_DREIE_bm;
     52e:	ec 85       	ldd	r30, Y+12	; 0x0c
     530:	fd 85       	ldd	r31, Y+13	; 0x0d
     532:	85 81       	ldd	r24, Z+5	; 0x05
     534:	80 62       	ori	r24, 0x20	; 32
     536:	e0 cf       	rjmp	.-64     	; 0x4f8 <UartClass::write(unsigned char)+0x32>

00000538 <UartClass::flush()>:
_ZN9UartClass5flushEv():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:332
    return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
  }
  return tail - head - 1;
}

void UartClass::flush() {
     538:	cf 93       	push	r28
     53a:	df 93       	push	r29
     53c:	ec 01       	movw	r28, r24
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:336
  // If we have never written a byte, no need to flush. This special
  // case is needed since there is no way to force the TXCIF (transmit
  // complete) bit to 1 during initialization
  if (!_written) {
     53e:	8d 89       	ldd	r24, Y+21	; 0x15
     540:	88 23       	and	r24, r24
     542:	61 f0       	breq	.+24     	; 0x55c <UartClass::flush()+0x24>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:351
  // it's appropriate to use for applications where it has only very small benefits, and significant risk of surprising the user and causing
  // breakage of code that would otherwise work. Finally, the previous implementation didn't check if it was called from the current lvl1 ISR
  // and in that case flush(), and write() with full buffer would just straight up hang...

  // Spin until the data-register-empty-interrupt is disabled and TX complete interrupt flag is raised
  while (((*_hwserial_module).CTRLA & USART_DREIE_bm) || (!((*_hwserial_module).STATUS & USART_TXCIF_bm))) {
     544:	ec 85       	ldd	r30, Y+12	; 0x0c
     546:	fd 85       	ldd	r31, Y+13	; 0x0d
     548:	85 81       	ldd	r24, Z+5	; 0x05
     54a:	85 fd       	sbrc	r24, 5
     54c:	03 c0       	rjmp	.+6      	; 0x554 <UartClass::flush()+0x1c>
     54e:	84 81       	ldd	r24, Z+4	; 0x04
     550:	86 fd       	sbrc	r24, 6
     552:	04 c0       	rjmp	.+8      	; 0x55c <UartClass::flush()+0x24>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:355

    // If interrupts are globally disabled or the and DR empty interrupt is disabled,
    // poll the "data register empty" interrupt flag to prevent deadlock
    _poll_tx_data_empty();
     554:	ce 01       	movw	r24, r28
     556:	0e 94 50 02 	call	0x4a0	; 0x4a0 <UartClass::_poll_tx_data_empty()>
     55a:	f4 cf       	rjmp	.-24     	; 0x544 <UartClass::flush()+0xc>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:359
  }
  // When we get here, nothing is queued anymore (DREIE is disabled) and
  // the hardware finished transmission (TXCIF is set).
}
     55c:	df 91       	pop	r29
     55e:	cf 91       	pop	r28
     560:	08 95       	ret

00000562 <Serial0_available()>:
_Z17Serial0_availablev():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART0.cpp:62
#endif

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
     562:	82 e8       	ldi	r24, 0x82	; 130
     564:	99 e3       	ldi	r25, 0x39	; 57
     566:	0e 94 00 02 	call	0x400	; 0x400 <UartClass::available()>
     56a:	21 e0       	ldi	r18, 0x01	; 1
     56c:	89 2b       	or	r24, r25
     56e:	09 f4       	brne	.+2      	; 0x572 <Serial0_available()+0x10>
     570:	20 e0       	ldi	r18, 0x00	; 0
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART0.cpp:63
}
     572:	82 2f       	mov	r24, r18
     574:	08 95       	ret

00000576 <serialEventRun()>:
_Z14serialEventRunv():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:66
  bool Serial3_available() __attribute__((weak));
#endif

void serialEventRun(void) {
  #if defined(HAVE_HWSERIAL0)
  if (Serial0_available && serialEvent && Serial0_available()) {
     576:	80 e0       	ldi	r24, 0x00	; 0
     578:	90 e0       	ldi	r25, 0x00	; 0
     57a:	89 2b       	or	r24, r25
     57c:	29 f0       	breq	.+10     	; 0x588 <serialEventRun()+0x12>
     57e:	0e 94 b1 02 	call	0x562	; 0x562 <Serial0_available()>
     582:	81 11       	cpse	r24, r1
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:67
    serialEvent();
     584:	0c 94 00 00 	jmp	0	; 0x0 <__TEXT_REGION_ORIGIN__>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:85
  #if defined(HAVE_HWSERIAL3)
  if (Serial3_available && serialEvent3 && Serial3_available()) {
    serialEvent3();
  }
  #endif
}
     588:	08 95       	ret

0000058a <TwoWire::onRequestService()>:
_ZN7TwoWire16onRequestServiceEv():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src/Wire.cpp:380
}

// behind the scenes function that is called when data is requested
uint8_t TwoWire::onRequestService(void) {
  // don't bother if user hasn't registered a callback
  if (!user_onRequest) {
     58a:	e0 91 68 38 	lds	r30, 0x3868	; 0x803868 <TwoWire::user_onRequest>
     58e:	f0 91 69 38 	lds	r31, 0x3869	; 0x803869 <TwoWire::user_onRequest+0x1>
     592:	30 97       	sbiw	r30, 0x00	; 0
     594:	41 f0       	breq	.+16     	; 0x5a6 <TwoWire::onRequestService()+0x1c>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src/Wire.cpp:385
    return 0;
  }

  // reset slave write buffer iterator var
  txBufferIndex = 0;
     596:	10 92 63 38 	sts	0x3863, r1	; 0x803863 <TwoWire::txBufferIndex>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src/Wire.cpp:386
  txBufferLength = 0;
     59a:	10 92 62 38 	sts	0x3862, r1	; 0x803862 <TwoWire::txBufferLength>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src/Wire.cpp:389

  // alert user program
  user_onRequest();
     59e:	09 95       	icall
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src/Wire.cpp:391

  return txBufferLength;
     5a0:	80 91 62 38 	lds	r24, 0x3862	; 0x803862 <TwoWire::txBufferLength>
     5a4:	08 95       	ret
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src/Wire.cpp:381

// behind the scenes function that is called when data is requested
uint8_t TwoWire::onRequestService(void) {
  // don't bother if user hasn't registered a callback
  if (!user_onRequest) {
    return 0;
     5a6:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src/Wire.cpp:392

  // alert user program
  user_onRequest();

  return txBufferLength;
}
     5a8:	08 95       	ret

000005aa <TwoWire::onReceiveService(int)>:
_ZN7TwoWire16onReceiveServiceEi():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src/Wire.cpp:359
}

// behind the scenes function that is called when data is received
void TwoWire::onReceiveService(int numBytes) {
  // don't bother if user hasn't registered a callback
  if (!user_onReceive) {
     5aa:	e0 91 66 38 	lds	r30, 0x3866	; 0x803866 <TwoWire::user_onReceive>
     5ae:	f0 91 67 38 	lds	r31, 0x3867	; 0x803867 <TwoWire::user_onReceive+0x1>
     5b2:	30 97       	sbiw	r30, 0x00	; 0
     5b4:	59 f0       	breq	.+22     	; 0x5cc <TwoWire::onReceiveService(int)+0x22>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src/Wire.cpp:365
    return;
  }
  // don't bother if rx buffer is in use by a master requestFrom() op
  // i know this drops data, but it allows for slight stupidity
  // meaning, they may not have read all the master requestFrom() data yet
  if (rxBufferIndex < rxBufferLength) {
     5b6:	30 91 65 38 	lds	r19, 0x3865	; 0x803865 <TwoWire::rxBufferIndex>
     5ba:	20 91 64 38 	lds	r18, 0x3864	; 0x803864 <TwoWire::rxBufferLength>
     5be:	32 17       	cp	r19, r18
     5c0:	28 f0       	brcs	.+10     	; 0x5cc <TwoWire::onReceiveService(int)+0x22>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src/Wire.cpp:370
    return;
  }

  // set rx iterator vars
  rxBufferIndex = 0;
     5c2:	10 92 65 38 	sts	0x3865, r1	; 0x803865 <TwoWire::rxBufferIndex>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src/Wire.cpp:371
  rxBufferLength = numBytes;
     5c6:	80 93 64 38 	sts	0x3864, r24	; 0x803864 <TwoWire::rxBufferLength>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src/Wire.cpp:374

  // alert user program
  user_onReceive(numBytes);
     5ca:	09 94       	ijmp
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src/Wire.cpp:375
}
     5cc:	08 95       	ret

000005ce <Print::write(unsigned char const*, unsigned int)>:
_ZN5Print5writeEPKhj():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore\api/Print.cpp:29
#include "Print.h"

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size) {
     5ce:	af 92       	push	r10
     5d0:	bf 92       	push	r11
     5d2:	cf 92       	push	r12
     5d4:	df 92       	push	r13
     5d6:	ef 92       	push	r14
     5d8:	ff 92       	push	r15
     5da:	0f 93       	push	r16
     5dc:	1f 93       	push	r17
     5de:	cf 93       	push	r28
     5e0:	df 93       	push	r29
     5e2:	6c 01       	movw	r12, r24
     5e4:	7b 01       	movw	r14, r22
     5e6:	8b 01       	movw	r16, r22
     5e8:	04 0f       	add	r16, r20
     5ea:	15 1f       	adc	r17, r21
     5ec:	eb 01       	movw	r28, r22
     5ee:	5e 01       	movw	r10, r28
     5f0:	ae 18       	sub	r10, r14
     5f2:	bf 08       	sbc	r11, r15
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore\api/Print.cpp:31
  size_t n = 0;
  while (size--) {
     5f4:	c0 17       	cp	r28, r16
     5f6:	d1 07       	cpc	r29, r17
     5f8:	59 f0       	breq	.+22     	; 0x610 <Print::write(unsigned char const*, unsigned int)+0x42>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore\api/Print.cpp:32
    if (write(*buffer++)) {
     5fa:	69 91       	ld	r22, Y+
     5fc:	d6 01       	movw	r26, r12
     5fe:	ed 91       	ld	r30, X+
     600:	fc 91       	ld	r31, X
     602:	01 90       	ld	r0, Z+
     604:	f0 81       	ld	r31, Z
     606:	e0 2d       	mov	r30, r0
     608:	c6 01       	movw	r24, r12
     60a:	09 95       	icall
     60c:	89 2b       	or	r24, r25
     60e:	79 f7       	brne	.-34     	; 0x5ee <Print::write(unsigned char const*, unsigned int)+0x20>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore\api/Print.cpp:39
    } else {
      break;
    }
  }
  return n;
}
     610:	c5 01       	movw	r24, r10
     612:	df 91       	pop	r29
     614:	cf 91       	pop	r28
     616:	1f 91       	pop	r17
     618:	0f 91       	pop	r16
     61a:	ff 90       	pop	r15
     61c:	ef 90       	pop	r14
     61e:	df 90       	pop	r13
     620:	cf 90       	pop	r12
     622:	bf 90       	pop	r11
     624:	af 90       	pop	r10
     626:	08 95       	ret

00000628 <UartClass::operator bool()>:
_ZN9UartClasscvbEv():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.h:223
      return write((uint8_t)n);
    }
    using Print::write; // pull in write(str) and write(buf, size) from Print
    explicit operator bool() {
      return true;
    }
     628:	81 e0       	ldi	r24, 0x01	; 1
     62a:	08 95       	ret

0000062c <micros>:
micros():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:207
  #else
  uint8_t ticks;
  #endif

  /* Save current state and disable interrupts */
  uint8_t status = SREG;
     62c:	8f b7       	in	r24, 0x3f	; 63
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:208
  cli();
     62e:	f8 94       	cli
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:214



  /* Get current number of overflows and timer count */
  #if !(defined(MILLIS_USE_TIMERB0)  || defined(MILLIS_USE_TIMERB1) )
  overflows = timer_overflow_count;
     630:	20 91 0e 38 	lds	r18, 0x380E	; 0x80380e <timer_overflow_count>
     634:	30 91 0f 38 	lds	r19, 0x380F	; 0x80380f <timer_overflow_count+0x1>
     638:	40 91 10 38 	lds	r20, 0x3810	; 0x803810 <timer_overflow_count+0x2>
     63c:	50 91 11 38 	lds	r21, 0x3811	; 0x803811 <timer_overflow_count+0x3>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:222
  #endif

  #if defined(MILLIS_USE_TIMERA0)
  ticks = (TIME_TRACKING_TIMER_PERIOD) - TCA0.SPLIT.HCNT;
  #elif defined(MILLIS_USE_TIMERD0)
  TCD0.CTRLE = TCD_SCAPTUREA_bm;
     640:	98 e0       	ldi	r25, 0x08	; 8
     642:	90 93 84 0a 	sts	0x0A84, r25	; 0x800a84 <digital_pin_to_port+0x7f7030>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:223
  while (!(TCD0.STATUS & TCD_CMDRDY_bm)); //wait for sync - should be only one iteration of this loop
     646:	90 91 8e 0a 	lds	r25, 0x0A8E	; 0x800a8e <digital_pin_to_port+0x7f703a>
     64a:	91 ff       	sbrs	r25, 1
     64c:	fc cf       	rjmp	.-8      	; 0x646 <micros+0x1a>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:224
  ticks = TCD0.CAPTUREA;
     64e:	e0 91 a2 0a 	lds	r30, 0x0AA2	; 0x800aa2 <digital_pin_to_port+0x7f704e>
     652:	f0 91 a3 0a 	lds	r31, 0x0AA3	; 0x800aa3 <digital_pin_to_port+0x7f704f>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:233
  /* If the timer overflow flag is raised, and the ticks we read are low, then the timer has rolled over but
    ISR has not fired. If we already read a high value of ticks, either we read it just before the overflow,
    so we shouldn't increment overflows, or interrupts are disabled and micros isn't expected to work so it doesn't matter
  */
  #if defined(MILLIS_USE_TIMERD0)
  if ((TCD0.INTFLAGS & TCD_OVF_bm) && !(ticks & 0xFF00)) {
     656:	90 91 8d 0a 	lds	r25, 0x0A8D	; 0x800a8d <digital_pin_to_port+0x7f7039>
     65a:	90 ff       	sbrs	r25, 0
     65c:	08 c0       	rjmp	.+16     	; 0x66e <micros+0x42>
     65e:	bf 01       	movw	r22, r30
     660:	66 27       	eor	r22, r22
     662:	67 2b       	or	r22, r23
     664:	21 f4       	brne	.+8      	; 0x66e <micros+0x42>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:242
  if ((_timer->INTFLAGS & TCB_CAPT_bm) && !(ticks & 0xFF00)) {
  #endif
    #if ((defined(MILLIS_USE_TIMERB0)|defined(MILLIS_USE_TIMERB1))&&(F_CPU>1000000))
    overflows++;
    #else
    overflows += 2;
     666:	2e 5f       	subi	r18, 0xFE	; 254
     668:	3f 4f       	sbci	r19, 0xFF	; 255
     66a:	4f 4f       	sbci	r20, 0xFF	; 255
     66c:	5f 4f       	sbci	r21, 0xFF	; 255
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:249
  }

  //end getting ticks

  /* Restore state */
  SREG = status;
     66e:	8f bf       	out	0x3f, r24	; 63
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:252
  #if defined(MILLIS_USE_TIMERD0)
  #if (F_CPU==20000000UL || F_CPU==10000000UL || F_CPU==5000000UL)
  uint8_t ticks_l = ticks >> 1;
     670:	bf 01       	movw	r22, r30
     672:	76 95       	lsr	r23
     674:	67 95       	ror	r22
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:253
  ticks = ticks + ticks_l + ((ticks_l >> 2) - (ticks_l >> 4) + (ticks_l >> 7));
     676:	cf 01       	movw	r24, r30
     678:	86 0f       	add	r24, r22
     67a:	91 1d       	adc	r25, r1
     67c:	e6 2f       	mov	r30, r22
     67e:	e6 95       	lsr	r30
     680:	e6 95       	lsr	r30
     682:	76 2f       	mov	r23, r22
     684:	72 95       	swap	r23
     686:	7f 70       	andi	r23, 0x0F	; 15
     688:	e7 1b       	sub	r30, r23
     68a:	ff 0b       	sbc	r31, r31
     68c:	67 fd       	sbrc	r22, 7
     68e:	31 96       	adiw	r30, 0x01	; 1
     690:	e8 0f       	add	r30, r24
     692:	f9 1f       	adc	r31, r25
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:254
  microseconds = overflows * (TIME_TRACKING_CYCLES_PER_OVF / (20))
     694:	a0 e3       	ldi	r26, 0x30	; 48
     696:	b3 e0       	ldi	r27, 0x03	; 3
     698:	0e 94 d9 0c 	call	0x19b2	; 0x19b2 <__muluhisi3>
     69c:	6e 0f       	add	r22, r30
     69e:	7f 1f       	adc	r23, r31
     6a0:	81 1d       	adc	r24, r1
     6a2:	91 1d       	adc	r25, r1
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:299
  microseconds = ((overflows * millisClockCyclesToMicroseconds(TIME_TRACKING_CYCLES_PER_OVF))
                  + (ticks * (millisClockCyclesToMicroseconds(TIME_TRACKING_CYCLES_PER_OVF) / TIME_TRACKING_TIMER_PERIOD)));
  #endif
  #endif //end of timer-specific part of micros calculations
  return microseconds;
}
     6a4:	08 95       	ret

000006a6 <tinyNeoPixel::show() [clone .constprop.18]>:
_ZN12tinyNeoPixel4showEv.constprop.18():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.cpp:76
  //if(pixels)   free(pixels);
  //if(pin >= 0) pinMode(pin, INPUT);
}


void tinyNeoPixel::show(void) {
     6a6:	0f 93       	push	r16
     6a8:	1f 93       	push	r17
     6aa:	cf 93       	push	r28
     6ac:	df 93       	push	r29
     6ae:	cd b7       	in	r28, 0x3d	; 61
     6b0:	de b7       	in	r29, 0x3e	; 62
     6b2:	27 97       	sbiw	r28, 0x07	; 7
     6b4:	cd bf       	out	0x3d, r28	; 61
     6b6:	de bf       	out	0x3e, r29	; 62
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.cpp:78

  if ((!pixels) || pin >= NUM_DIGITAL_PINS )  {
     6b8:	80 91 53 3a 	lds	r24, 0x3A53	; 0x803a53 <strip+0x6>
     6bc:	90 91 54 3a 	lds	r25, 0x3A54	; 0x803a54 <strip+0x7>
     6c0:	89 2b       	or	r24, r25
     6c2:	09 f4       	brne	.+2      	; 0x6c6 <tinyNeoPixel::show() [clone .constprop.18]+0x20>
     6c4:	6e c0       	rjmp	.+220    	; 0x7a2 <nextbyte20+0x3a>
     6c6:	80 91 51 3a 	lds	r24, 0x3A51	; 0x803a51 <strip+0x4>
     6ca:	8c 30       	cpi	r24, 0x0C	; 12
     6cc:	0c f0       	brlt	.+2      	; 0x6d0 <tinyNeoPixel::show() [clone .constprop.18]+0x2a>
     6ce:	69 c0       	rjmp	.+210    	; 0x7a2 <nextbyte20+0x3a>
_ZN12tinyNeoPixel7canShowEv.isra.0():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.h:297
  */
  static uint32_t gamma32(uint32_t x);

  #ifndef DISABLEMILLIS
    inline bool canShow(void) {
      return (micros() - endTime) >= 50L;
     6d0:	0e 94 16 03 	call	0x62c	; 0x62c <micros>
     6d4:	00 91 59 3a 	lds	r16, 0x3A59	; 0x803a59 <strip+0xc>
     6d8:	10 91 5a 3a 	lds	r17, 0x3A5A	; 0x803a5a <strip+0xd>
     6dc:	20 91 5b 3a 	lds	r18, 0x3A5B	; 0x803a5b <strip+0xe>
     6e0:	30 91 5c 3a 	lds	r19, 0x3A5C	; 0x803a5c <strip+0xf>
     6e4:	60 1b       	sub	r22, r16
     6e6:	71 0b       	sbc	r23, r17
     6e8:	82 0b       	sbc	r24, r18
     6ea:	93 0b       	sbc	r25, r19
_ZN12tinyNeoPixel4showEv.constprop.18():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.cpp:88
  // put a delay at the end of the function, the ending time is noted and
  // the function will simply hold off (if needed) on issuing the
  // subsequent round of data until the latch time has elapsed.  This
  // allows the mainline code to start generating the next frame of data
  // rather than stalling for the latch.
  while (!canShow());
     6ec:	62 33       	cpi	r22, 0x32	; 50
     6ee:	71 05       	cpc	r23, r1
     6f0:	81 05       	cpc	r24, r1
     6f2:	91 05       	cpc	r25, r1
     6f4:	68 f3       	brcs	.-38     	; 0x6d0 <tinyNeoPixel::show() [clone .constprop.18]+0x2a>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.cpp:103
  // while data is being issued to the LEDs, so no other code will be
  // accessing the PORT.  The code takes an initial 'snapshot' of the PORT
  // state, computes 'pin high' and 'pin low' values, and writes these back
  // to the PORT register as needed.

  noInterrupts(); // Need 100% focus on instruction timing
     6f6:	f8 94       	cli
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.cpp:113
  // Dx-series parts. This is by no means intended to imply that they will
  // run at those speeds, only that - if they do - you can control WS2812s
  // with them.

  volatile uint16_t
    i   = numBytes; // Loop counter
     6f8:	80 91 4f 3a 	lds	r24, 0x3A4F	; 0x803a4f <strip+0x2>
     6fc:	90 91 50 3a 	lds	r25, 0x3A50	; 0x803a50 <strip+0x3>
     700:	89 83       	std	Y+1, r24	; 0x01
     702:	9a 83       	std	Y+2, r25	; 0x02
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.cpp:115
  volatile uint8_t
   *ptr = pixels,   // Pointer to next byte
     704:	e0 91 53 3a 	lds	r30, 0x3A53	; 0x803a53 <strip+0x6>
     708:	f0 91 54 3a 	lds	r31, 0x3A54	; 0x803a54 <strip+0x7>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.cpp:116
    b   = *ptr++,   // Current byte value
     70c:	df 01       	movw	r26, r30
     70e:	11 96       	adiw	r26, 0x01	; 1
     710:	80 81       	ld	r24, Z
     712:	8f 83       	std	Y+7, r24	; 0x07
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.cpp:432
    // 25 inst. clocks per bit: HHHHHHHxxxxxxxxLLLLLLLLLL
    // ST instructions:         ^      ^       ^       (T=0,7,15)

    volatile uint8_t next, bit;

    hi   = *port |  pinMask;
     714:	e0 91 5d 3a 	lds	r30, 0x3A5D	; 0x803a5d <strip+0x10>
     718:	f0 91 5e 3a 	lds	r31, 0x3A5E	; 0x803a5e <strip+0x11>
     71c:	90 81       	ld	r25, Z
     71e:	80 91 5f 3a 	lds	r24, 0x3A5F	; 0x803a5f <strip+0x12>
     722:	98 2b       	or	r25, r24
     724:	9e 83       	std	Y+6, r25	; 0x06
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.cpp:433
    lo   = *port & ~pinMask;
     726:	90 81       	ld	r25, Z
     728:	80 95       	com	r24
     72a:	89 23       	and	r24, r25
     72c:	8d 83       	std	Y+5, r24	; 0x05
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.cpp:434
    next = lo;
     72e:	8d 81       	ldd	r24, Y+5	; 0x05
     730:	8c 83       	std	Y+4, r24	; 0x04
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.cpp:435
    bit  = 8;
     732:	88 e0       	ldi	r24, 0x08	; 8
     734:	8b 83       	std	Y+3, r24	; 0x03
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.cpp:474
      [bit]   "+r" (bit),
      [next]  "+r" (next),
      [count] "+w" (i)
    : [ptr]    "e" (ptr),
      [hi]     "r" (hi),
      [lo]     "r" (lo));
     736:	5e 81       	ldd	r21, Y+6	; 0x06
     738:	6d 81       	ldd	r22, Y+5	; 0x05
     73a:	4f 81       	ldd	r20, Y+7	; 0x07
     73c:	3b 81       	ldd	r19, Y+3	; 0x03
     73e:	2c 81       	ldd	r18, Y+4	; 0x04
     740:	89 81       	ldd	r24, Y+1	; 0x01
     742:	9a 81       	ldd	r25, Y+2	; 0x02

00000744 <head20>:
     744:	50 83       	st	Z, r21
     746:	47 fd       	sbrc	r20, 7
     748:	25 2f       	mov	r18, r21
     74a:	3a 95       	dec	r19
     74c:	00 00       	nop
     74e:	00 c0       	rjmp	.+0      	; 0x750 <head20+0xc>
     750:	20 83       	st	Z, r18
     752:	26 2f       	mov	r18, r22
     754:	49 f0       	breq	.+18     	; 0x768 <nextbyte20>
     756:	44 1f       	adc	r20, r20
     758:	00 c0       	rjmp	.+0      	; 0x75a <head20+0x16>
     75a:	00 c0       	rjmp	.+0      	; 0x75c <head20+0x18>
     75c:	60 83       	st	Z, r22
     75e:	00 00       	nop
     760:	00 c0       	rjmp	.+0      	; 0x762 <head20+0x1e>
     762:	00 c0       	rjmp	.+0      	; 0x764 <head20+0x20>
     764:	00 c0       	rjmp	.+0      	; 0x766 <head20+0x22>
     766:	ee cf       	rjmp	.-36     	; 0x744 <head20>

00000768 <nextbyte20>:
     768:	38 e0       	ldi	r19, 0x08	; 8
     76a:	4d 91       	ld	r20, X+
     76c:	00 00       	nop
     76e:	60 83       	st	Z, r22
     770:	00 00       	nop
     772:	00 c0       	rjmp	.+0      	; 0x774 <nextbyte20+0xc>
     774:	00 c0       	rjmp	.+0      	; 0x776 <nextbyte20+0xe>
     776:	01 97       	sbiw	r24, 0x01	; 1
     778:	29 f7       	brne	.-54     	; 0x744 <head20>
     77a:	e0 93 5d 3a 	sts	0x3A5D, r30	; 0x803a5d <strip+0x10>
     77e:	f0 93 5e 3a 	sts	0x3A5E, r31	; 0x803a5e <strip+0x11>
     782:	4f 83       	std	Y+7, r20	; 0x07
     784:	3b 83       	std	Y+3, r19	; 0x03
     786:	2c 83       	std	Y+4, r18	; 0x04
     788:	89 83       	std	Y+1, r24	; 0x01
     78a:	9a 83       	std	Y+2, r25	; 0x02
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.cpp:820
#endif

  // END AVR ----------------------------------------------------------------


  interrupts();
     78c:	78 94       	sei
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.cpp:822
  #ifndef DISABLEMILLIS
  endTime = micros(); // Save EOD time for latch on next call
     78e:	0e 94 16 03 	call	0x62c	; 0x62c <micros>
     792:	60 93 59 3a 	sts	0x3A59, r22	; 0x803a59 <strip+0xc>
     796:	70 93 5a 3a 	sts	0x3A5A, r23	; 0x803a5a <strip+0xd>
     79a:	80 93 5b 3a 	sts	0x3A5B, r24	; 0x803a5b <strip+0xe>
     79e:	90 93 5c 3a 	sts	0x3A5C, r25	; 0x803a5c <strip+0xf>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.cpp:824
  #endif
}
     7a2:	27 96       	adiw	r28, 0x07	; 7
     7a4:	cd bf       	out	0x3d, r28	; 61
     7a6:	de bf       	out	0x3e, r29	; 62
     7a8:	df 91       	pop	r29
     7aa:	cf 91       	pop	r28
     7ac:	1f 91       	pop	r17
     7ae:	0f 91       	pop	r16
     7b0:	08 95       	ret

000007b2 <delay>:
delay():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:306


#endif //end of non-MILLIS_USE_TIMERNONE code

#if !(defined(MILLIS_USE_TIMERNONE) || defined(MILLIS_USE_TIMERRTC)) //delay implementation when we do have micros()
void delay(unsigned long ms) {
     7b2:	8f 92       	push	r8
     7b4:	9f 92       	push	r9
     7b6:	af 92       	push	r10
     7b8:	bf 92       	push	r11
     7ba:	cf 92       	push	r12
     7bc:	df 92       	push	r13
     7be:	ef 92       	push	r14
     7c0:	ff 92       	push	r15
     7c2:	4b 01       	movw	r8, r22
     7c4:	5c 01       	movw	r10, r24
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:307
  uint32_t start_time = micros(), delay_time = 1000 * ms;
     7c6:	0e 94 16 03 	call	0x62c	; 0x62c <micros>
     7ca:	6b 01       	movw	r12, r22
     7cc:	7c 01       	movw	r14, r24
     7ce:	a8 ee       	ldi	r26, 0xE8	; 232
     7d0:	b3 e0       	ldi	r27, 0x03	; 3
     7d2:	a5 01       	movw	r20, r10
     7d4:	94 01       	movw	r18, r8
     7d6:	0e 94 d9 0c 	call	0x19b2	; 0x19b2 <__muluhisi3>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:310

  /* Calculate future time to return */
  uint32_t return_time = start_time + delay_time;
     7da:	c6 0e       	add	r12, r22
     7dc:	d7 1e       	adc	r13, r23
     7de:	e8 1e       	adc	r14, r24
     7e0:	f9 1e       	adc	r15, r25
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:313

  /* If return time overflows */
  if (return_time < delay_time) {
     7e2:	c6 16       	cp	r12, r22
     7e4:	d7 06       	cpc	r13, r23
     7e6:	e8 06       	cpc	r14, r24
     7e8:	f9 06       	cpc	r15, r25
     7ea:	18 f4       	brcc	.+6      	; 0x7f2 <delay+0x40>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:315
    /* Wait until micros overflows */
    while (micros() > return_time);
     7ec:	0e 94 16 03 	call	0x62c	; 0x62c <micros>
     7f0:	f8 cf       	rjmp	.-16     	; 0x7e2 <delay+0x30>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:319
  }

  /* Wait until return time */
  while (micros() < return_time);
     7f2:	0e 94 16 03 	call	0x62c	; 0x62c <micros>
     7f6:	6c 15       	cp	r22, r12
     7f8:	7d 05       	cpc	r23, r13
     7fa:	8e 05       	cpc	r24, r14
     7fc:	9f 05       	cpc	r25, r15
     7fe:	c8 f3       	brcs	.-14     	; 0x7f2 <delay+0x40>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:320
}
     800:	ff 90       	pop	r15
     802:	ef 90       	pop	r14
     804:	df 90       	pop	r13
     806:	cf 90       	pop	r12
     808:	bf 90       	pop	r11
     80a:	af 90       	pop	r10
     80c:	9f 90       	pop	r9
     80e:	8f 90       	pop	r8
     810:	08 95       	ret

00000812 <TWI_SlaveTransactionFinished>:
TWI_SlaveTransactionFinished():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:755
    Prepares module for new transaction.

    \param result  The result of the operation.
*/
void TWI_SlaveTransactionFinished(uint8_t result) {
  TWI0.SCTRLA |= (TWI_APIEN_bm | TWI_PIEN_bm);
     812:	e0 e1       	ldi	r30, 0x10	; 16
     814:	f8 e0       	ldi	r31, 0x08	; 8
     816:	91 85       	ldd	r25, Z+9	; 0x09
     818:	90 66       	ori	r25, 0x60	; 96
     81a:	91 87       	std	Z+9, r25	; 0x09
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:756
  twi_mode = TWI_MODE_SLAVE;
     81c:	92 e0       	ldi	r25, 0x02	; 2
     81e:	90 93 21 38 	sts	0x3821, r25	; 0x803821 <twi_mode>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:757
  slave_result = result;
     822:	80 93 1d 38 	sts	0x381D, r24	; 0x80381d <slave_result>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:758
  slave_trans_status = TWIM_STATUS_READY;
     826:	10 92 1e 38 	sts	0x381E, r1	; 0x80381e <slave_trans_status>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:759
}
     82a:	08 95       	ret

0000082c <TWI_SlaveAddressMatchHandler>:
TWI_SlaveAddressMatchHandler():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:600
    This is the slave address match handler that takes care of responding to
    being addressed by a master

*/
void TWI_SlaveAddressMatchHandler() {
  slave_trans_status = TWIS_STATUS_BUSY;
     82c:	81 e0       	ldi	r24, 0x01	; 1
     82e:	80 93 1e 38 	sts	0x381E, r24	; 0x80381e <slave_trans_status>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:601
  slave_result = TWIS_RESULT_UNKNOWN;
     832:	10 92 1d 38 	sts	0x381D, r1	; 0x80381d <slave_result>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:604

  /* If Master Read/Slave Write */
  if (TWI0.SSTATUS & TWI_DIR_bm) {
     836:	90 91 1b 08 	lds	r25, 0x081B	; 0x80081b <digital_pin_to_port+0x7f6dc7>
     83a:	91 ff       	sbrs	r25, 1
     83c:	10 c0       	rjmp	.+32     	; 0x85e <TWI_SlaveAddressMatchHandler+0x32>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:605
    slave_bytesWritten = 0;
     83e:	10 92 1f 38 	sts	0x381F, r1	; 0x80381f <slave_bytesWritten>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:607
    /* Call user function  */
    slave_bytesToWrite = TWI_onSlaveTransmit();
     842:	e0 91 19 38 	lds	r30, 0x3819	; 0x803819 <TWI_onSlaveTransmit>
     846:	f0 91 1a 38 	lds	r31, 0x381A	; 0x80381a <TWI_onSlaveTransmit+0x1>
     84a:	09 95       	icall
     84c:	80 93 0b 38 	sts	0x380B, r24	; 0x80380b <slave_bytesToWrite>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:608
    twi_mode = TWI_MODE_SLAVE_TRANSMIT;
     850:	85 e0       	ldi	r24, 0x05	; 5
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:614
  }
  /* If Master Write/Slave Read */
  else {
    slave_bytesRead = 0;
    slave_callUserReceive = 1;
    twi_mode = TWI_MODE_SLAVE_RECEIVE;
     852:	80 93 21 38 	sts	0x3821, r24	; 0x803821 <twi_mode>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:618
  }

  /* Send ACK, wait for data interrupt */
  TWI0.SCTRLB = TWI_SCMD_RESPONSE_gc;
     856:	83 e0       	ldi	r24, 0x03	; 3
     858:	80 93 1a 08 	sts	0x081A, r24	; 0x80081a <digital_pin_to_port+0x7f6dc6>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:621

  /* Data interrupt to follow... */
}
     85c:	08 95       	ret
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:612
    slave_bytesToWrite = TWI_onSlaveTransmit();
    twi_mode = TWI_MODE_SLAVE_TRANSMIT;
  }
  /* If Master Write/Slave Read */
  else {
    slave_bytesRead = 0;
     85e:	10 92 20 38 	sts	0x3820, r1	; 0x803820 <slave_bytesRead>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:613
    slave_callUserReceive = 1;
     862:	80 93 1b 38 	sts	0x381B, r24	; 0x80381b <slave_callUserReceive>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:614
    twi_mode = TWI_MODE_SLAVE_RECEIVE;
     866:	86 e0       	ldi	r24, 0x06	; 6
     868:	f4 cf       	rjmp	.-24     	; 0x852 <TWI_SlaveAddressMatchHandler+0x26>

0000086a <TwoWire::flush()>:
_ZN7TwoWire5flushEv():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src/Wire.cpp:354
  //  rxBufferIndex = 0;
  //  rxBufferLength = 0;
  //
  //  /* Turn off and on TWI module */
  //  TWI_Flush();
}
     86a:	08 95       	ret

0000086c <TwoWire::peek()>:
_ZN7TwoWire4peekEv():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src/Wire.cpp:330
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::peek(void) {
  int value = -1;

  if (rxBufferIndex < rxBufferLength) {
     86c:	e0 91 65 38 	lds	r30, 0x3865	; 0x803865 <TwoWire::rxBufferIndex>
     870:	80 91 64 38 	lds	r24, 0x3864	; 0x803864 <TwoWire::rxBufferLength>
     874:	e8 17       	cp	r30, r24
     876:	30 f4       	brcc	.+12     	; 0x884 <TwoWire::peek()+0x18>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src/Wire.cpp:331
    value = rxBuffer[rxBufferIndex];
     878:	f0 e0       	ldi	r31, 0x00	; 0
     87a:	ee 5d       	subi	r30, 0xDE	; 222
     87c:	f7 4c       	sbci	r31, 0xC7	; 199
     87e:	80 81       	ld	r24, Z
     880:	90 e0       	ldi	r25, 0x00	; 0
     882:	08 95       	ret
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src/Wire.cpp:328

// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::peek(void) {
  int value = -1;
     884:	8f ef       	ldi	r24, 0xFF	; 255
     886:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src/Wire.cpp:335
  if (rxBufferIndex < rxBufferLength) {
    value = rxBuffer[rxBufferIndex];
  }

  return value;
}
     888:	08 95       	ret

0000088a <TwoWire::read()>:
_ZN7TwoWire4readEv():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src/Wire.cpp:316
// or after requestFrom(address, numBytes)
int TwoWire::read(void) {
  int value = -1;

  // get each successive byte on each call
  if (rxBufferIndex < rxBufferLength) {
     88a:	90 91 65 38 	lds	r25, 0x3865	; 0x803865 <TwoWire::rxBufferIndex>
     88e:	80 91 64 38 	lds	r24, 0x3864	; 0x803864 <TwoWire::rxBufferLength>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src/Wire.cpp:313

// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::read(void) {
  int value = -1;
     892:	2f ef       	ldi	r18, 0xFF	; 255
     894:	3f ef       	ldi	r19, 0xFF	; 255
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src/Wire.cpp:316

  // get each successive byte on each call
  if (rxBufferIndex < rxBufferLength) {
     896:	98 17       	cp	r25, r24
     898:	48 f4       	brcc	.+18     	; 0x8ac <TwoWire::read()+0x22>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src/Wire.cpp:317
    value = rxBuffer[rxBufferIndex];
     89a:	e9 2f       	mov	r30, r25
     89c:	f0 e0       	ldi	r31, 0x00	; 0
     89e:	ee 5d       	subi	r30, 0xDE	; 222
     8a0:	f7 4c       	sbci	r31, 0xC7	; 199
     8a2:	20 81       	ld	r18, Z
     8a4:	30 e0       	ldi	r19, 0x00	; 0
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src/Wire.cpp:318
    rxBufferIndex++;
     8a6:	9f 5f       	subi	r25, 0xFF	; 255
     8a8:	90 93 65 38 	sts	0x3865, r25	; 0x803865 <TwoWire::rxBufferIndex>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src/Wire.cpp:322
  }

  return value;
}
     8ac:	c9 01       	movw	r24, r18
     8ae:	08 95       	ret

000008b0 <TwoWire::available()>:
_ZN7TwoWire9availableEv():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src/Wire.cpp:306

// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::available(void) {
  return rxBufferLength - rxBufferIndex;
     8b0:	80 91 64 38 	lds	r24, 0x3864	; 0x803864 <TwoWire::rxBufferLength>
     8b4:	90 91 65 38 	lds	r25, 0x3865	; 0x803865 <TwoWire::rxBufferIndex>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src/Wire.cpp:307
}
     8b8:	89 1b       	sub	r24, r25
     8ba:	99 0b       	sbc	r25, r25
     8bc:	08 95       	ret

000008be <TwoWire::write(unsigned char const*, unsigned int)>:
_ZN7TwoWire5writeEPKhj():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src/Wire.cpp:292
}

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity) {
     8be:	cf 92       	push	r12
     8c0:	df 92       	push	r13
     8c2:	ef 92       	push	r14
     8c4:	ff 92       	push	r15
     8c6:	0f 93       	push	r16
     8c8:	1f 93       	push	r17
     8ca:	cf 93       	push	r28
     8cc:	df 93       	push	r29
     8ce:	7c 01       	movw	r14, r24
     8d0:	8a 01       	movw	r16, r20
     8d2:	eb 01       	movw	r28, r22
     8d4:	6b 01       	movw	r12, r22
     8d6:	c4 0e       	add	r12, r20
     8d8:	d5 1e       	adc	r13, r21
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src/Wire.cpp:294

  for (size_t i = 0; i < quantity; i++) {
     8da:	cc 15       	cp	r28, r12
     8dc:	dd 05       	cpc	r29, r13
     8de:	51 f0       	breq	.+20     	; 0x8f4 <TwoWire::write(unsigned char const*, unsigned int)+0x36>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src/Wire.cpp:295
    write(*(data + i));
     8e0:	69 91       	ld	r22, Y+
     8e2:	d7 01       	movw	r26, r14
     8e4:	ed 91       	ld	r30, X+
     8e6:	fc 91       	ld	r31, X
     8e8:	01 90       	ld	r0, Z+
     8ea:	f0 81       	ld	r31, Z
     8ec:	e0 2d       	mov	r30, r0
     8ee:	c7 01       	movw	r24, r14
     8f0:	09 95       	icall
     8f2:	f3 cf       	rjmp	.-26     	; 0x8da <TwoWire::write(unsigned char const*, unsigned int)+0x1c>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src/Wire.cpp:299
  }

  return quantity;
}
     8f4:	c8 01       	movw	r24, r16
     8f6:	df 91       	pop	r29
     8f8:	cf 91       	pop	r28
     8fa:	1f 91       	pop	r17
     8fc:	0f 91       	pop	r16
     8fe:	ff 90       	pop	r15
     900:	ef 90       	pop	r14
     902:	df 90       	pop	r13
     904:	cf 90       	pop	r12
     906:	08 95       	ret

00000908 <TwoWire::write(unsigned char)>:
_ZN7TwoWire5writeEh():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src/Wire.cpp:274
// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(uint8_t data) {
  /* Check if buffer is full */
  if (txBufferLength >= BUFFER_LENGTH) {
     908:	20 91 62 38 	lds	r18, 0x3862	; 0x803862 <TwoWire::txBufferLength>
     90c:	20 32       	cpi	r18, 0x20	; 32
     90e:	40 f0       	brcs	.+16     	; 0x920 <TwoWire::write(unsigned char)+0x18>
_ZN5Print13setWriteErrorEi():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore\api/Print.h:39
    int write_error;
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) {
      write_error = err;
     910:	21 e0       	ldi	r18, 0x01	; 1
     912:	30 e0       	ldi	r19, 0x00	; 0
     914:	fc 01       	movw	r30, r24
     916:	22 83       	std	Z+2, r18	; 0x02
     918:	33 83       	std	Z+3, r19	; 0x03
_ZN7TwoWire5writeEh():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src/Wire.cpp:276
    setWriteError();
    return 0;
     91a:	90 e0       	ldi	r25, 0x00	; 0
     91c:	80 e0       	ldi	r24, 0x00	; 0
     91e:	08 95       	ret
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src/Wire.cpp:280
  }

  /* Put byte in txBuffer */
  txBuffer[txBufferIndex] = data;
     920:	80 91 63 38 	lds	r24, 0x3863	; 0x803863 <TwoWire::txBufferIndex>
     924:	e8 2f       	mov	r30, r24
     926:	f0 e0       	ldi	r31, 0x00	; 0
     928:	ee 5b       	subi	r30, 0xBE	; 190
     92a:	f7 4c       	sbci	r31, 0xC7	; 199
     92c:	60 83       	st	Z, r22
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src/Wire.cpp:281
  txBufferIndex++;
     92e:	8f 5f       	subi	r24, 0xFF	; 255
     930:	80 93 63 38 	sts	0x3863, r24	; 0x803863 <TwoWire::txBufferIndex>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src/Wire.cpp:284

  /* Update buffer length */
  txBufferLength = txBufferIndex;
     934:	80 93 62 38 	sts	0x3862, r24	; 0x803862 <TwoWire::txBufferLength>
     938:	81 e0       	ldi	r24, 0x01	; 1
     93a:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src/Wire.cpp:287

  return 1;
}
     93c:	08 95       	ret

0000093e <requestEvent()>:
_Z12requestEventv():
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:524


//byte startingNum = 0;
void requestEvent() {
   //byte count = 0;
   if(reg < 256 && reg >= 0 ){
     93e:	80 91 02 38 	lds	r24, 0x3802	; 0x803802 <reg>
     942:	80 91 02 38 	lds	r24, 0x3802	; 0x803802 <reg>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:525
     Wire.write(bufferI2C[reg]);
     946:	e0 91 02 38 	lds	r30, 0x3802	; 0x803802 <reg>
     94a:	f0 e0       	ldi	r31, 0x00	; 0
     94c:	e4 58       	subi	r30, 0x84	; 132
     94e:	f7 4c       	sbci	r31, 0xC7	; 199
     950:	60 81       	ld	r22, Z
     952:	8d e1       	ldi	r24, 0x1D	; 29
     954:	9a e3       	ldi	r25, 0x3A	; 58
     956:	0c 94 84 04 	jmp	0x908	; 0x908 <TwoWire::write(unsigned char)>

0000095a <show_pattern()>:
_Z12show_patternv():
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:294
    strip.show();
  }
  strip.show();
}

void show_pattern() {
     95a:	0f 93       	push	r16
     95c:	1f 93       	push	r17
     95e:	cf 93       	push	r28
     960:	df 93       	push	r29
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:295
  byte pattern_num = bufferI2C[1];
     962:	c0 91 7d 38 	lds	r28, 0x387D	; 0x80387d <bufferI2C+0x1>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:296
  for(byte i=0; i<strip.numPixels(); i++) {
     966:	10 e0       	ldi	r17, 0x00	; 0
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:297
    strip.setPixelColor(i, strip.Color(pattern[pattern_num][i*3], pattern[pattern_num][i*3+1], pattern[pattern_num][i*3+2] )); // set color from pattern
     968:	03 e0       	ldi	r16, 0x03	; 3
     96a:	8c e0       	ldi	r24, 0x0C	; 12
     96c:	c8 9f       	mul	r28, r24
     96e:	e0 01       	movw	r28, r0
     970:	11 24       	eor	r1, r1
     972:	c4 59       	subi	r28, 0x94	; 148
     974:	d7 4c       	sbci	r29, 0xC7	; 199
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:296
  strip.show();
}

void show_pattern() {
  byte pattern_num = bufferI2C[1];
  for(byte i=0; i<strip.numPixels(); i++) {
     976:	81 2f       	mov	r24, r17
     978:	90 e0       	ldi	r25, 0x00	; 0
     97a:	20 91 4d 3a 	lds	r18, 0x3A4D	; 0x803a4d <strip>
     97e:	30 91 4e 3a 	lds	r19, 0x3A4E	; 0x803a4e <strip+0x1>
     982:	82 17       	cp	r24, r18
     984:	93 07       	cpc	r25, r19
     986:	d0 f4       	brcc	.+52     	; 0x9bc <show_pattern()+0x62>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:297
    strip.setPixelColor(i, strip.Color(pattern[pattern_num][i*3], pattern[pattern_num][i*3+1], pattern[pattern_num][i*3+2] )); // set color from pattern
     988:	fe 01       	movw	r30, r28
     98a:	10 9f       	mul	r17, r16
     98c:	e0 0d       	add	r30, r0
     98e:	f1 1d       	adc	r31, r1
     990:	11 24       	eor	r1, r1
_ZN12tinyNeoPixel5ColorEhhh():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.h:263
             variable for later use or passed to the setPixelColor()
             function. Packed RGB format is predictable, regardless of
             LED strand color order.
  */
  static uint32_t   Color(uint8_t r, uint8_t g, uint8_t b) {
    return ((uint32_t)r << 16) | ((uint32_t)g <<  8) | b;
     992:	40 81       	ld	r20, Z
     994:	50 e0       	ldi	r21, 0x00	; 0
     996:	70 e0       	ldi	r23, 0x00	; 0
     998:	60 e0       	ldi	r22, 0x00	; 0
     99a:	ba 01       	movw	r22, r20
     99c:	55 27       	eor	r21, r21
     99e:	44 27       	eor	r20, r20
     9a0:	22 81       	ldd	r18, Z+2	; 0x02
     9a2:	42 2b       	or	r20, r18
     9a4:	21 81       	ldd	r18, Z+1	; 0x01
     9a6:	52 2b       	or	r21, r18
_Z12show_patternv():
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:297
     9a8:	0e 94 5e 01 	call	0x2bc	; 0x2bc <tinyNeoPixel::setPixelColor(unsigned int, unsigned long) [clone .constprop.6]>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:298
    delay(10);
     9ac:	6a e0       	ldi	r22, 0x0A	; 10
     9ae:	70 e0       	ldi	r23, 0x00	; 0
     9b0:	80 e0       	ldi	r24, 0x00	; 0
     9b2:	90 e0       	ldi	r25, 0x00	; 0
     9b4:	0e 94 d9 03 	call	0x7b2	; 0x7b2 <delay>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:296
  strip.show();
}

void show_pattern() {
  byte pattern_num = bufferI2C[1];
  for(byte i=0; i<strip.numPixels(); i++) {
     9b8:	1f 5f       	subi	r17, 0xFF	; 255
     9ba:	dd cf       	rjmp	.-70     	; 0x976 <show_pattern()+0x1c>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:301
    strip.setPixelColor(i, strip.Color(pattern[pattern_num][i*3], pattern[pattern_num][i*3+1], pattern[pattern_num][i*3+2] )); // set color from pattern
    delay(10);
  }
  strip.show();
}
     9bc:	df 91       	pop	r29
     9be:	cf 91       	pop	r28
     9c0:	1f 91       	pop	r17
     9c2:	0f 91       	pop	r16
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:300
  byte pattern_num = bufferI2C[1];
  for(byte i=0; i<strip.numPixels(); i++) {
    strip.setPixelColor(i, strip.Color(pattern[pattern_num][i*3], pattern[pattern_num][i*3+1], pattern[pattern_num][i*3+2] )); // set color from pattern
    delay(10);
  }
  strip.show();
     9c4:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <tinyNeoPixel::show() [clone .constprop.18]>

000009c8 <colorWipe(unsigned long, unsigned char)>:
_Z9colorWipemh():
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:277
  }
  nextState = true;
}

// Fill the dots one after the other with a color
void colorWipe(uint32_t c, uint8_t wait) {
     9c8:	8f 92       	push	r8
     9ca:	9f 92       	push	r9
     9cc:	af 92       	push	r10
     9ce:	bf 92       	push	r11
     9d0:	cf 92       	push	r12
     9d2:	df 92       	push	r13
     9d4:	ef 92       	push	r14
     9d6:	ff 92       	push	r15
     9d8:	cf 93       	push	r28
     9da:	df 93       	push	r29
     9dc:	4b 01       	movw	r8, r22
     9de:	5c 01       	movw	r10, r24
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:278
  for(uint16_t i=0; i<strip.numPixels() && !nextState; i++) {
     9e0:	d0 e0       	ldi	r29, 0x00	; 0
     9e2:	c0 e0       	ldi	r28, 0x00	; 0
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:281
    strip.setPixelColor(i, c);
    strip.show();
    delay(wait);
     9e4:	c4 2e       	mov	r12, r20
     9e6:	d1 2c       	mov	r13, r1
     9e8:	f1 2c       	mov	r15, r1
     9ea:	e1 2c       	mov	r14, r1
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:278
  nextState = true;
}

// Fill the dots one after the other with a color
void colorWipe(uint32_t c, uint8_t wait) {
  for(uint16_t i=0; i<strip.numPixels() && !nextState; i++) {
     9ec:	80 91 4d 3a 	lds	r24, 0x3A4D	; 0x803a4d <strip>
     9f0:	90 91 4e 3a 	lds	r25, 0x3A4E	; 0x803a4e <strip+0x1>
     9f4:	c8 17       	cp	r28, r24
     9f6:	d9 07       	cpc	r29, r25
     9f8:	88 f4       	brcc	.+34     	; 0xa1c <colorWipe(unsigned long, unsigned char)+0x54>
     9fa:	80 91 80 39 	lds	r24, 0x3980	; 0x803980 <nextState>
     9fe:	81 11       	cpse	r24, r1
     a00:	0d c0       	rjmp	.+26     	; 0xa1c <colorWipe(unsigned long, unsigned char)+0x54>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:279
    strip.setPixelColor(i, c);
     a02:	b5 01       	movw	r22, r10
     a04:	a4 01       	movw	r20, r8
     a06:	ce 01       	movw	r24, r28
     a08:	0e 94 5e 01 	call	0x2bc	; 0x2bc <tinyNeoPixel::setPixelColor(unsigned int, unsigned long) [clone .constprop.6]>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:280
    strip.show();
     a0c:	0e 94 53 03 	call	0x6a6	; 0x6a6 <tinyNeoPixel::show() [clone .constprop.18]>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:281
    delay(wait);
     a10:	c7 01       	movw	r24, r14
     a12:	b6 01       	movw	r22, r12
     a14:	0e 94 d9 03 	call	0x7b2	; 0x7b2 <delay>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:278
  nextState = true;
}

// Fill the dots one after the other with a color
void colorWipe(uint32_t c, uint8_t wait) {
  for(uint16_t i=0; i<strip.numPixels() && !nextState; i++) {
     a18:	21 96       	adiw	r28, 0x01	; 1
     a1a:	e8 cf       	rjmp	.-48     	; 0x9ec <colorWipe(unsigned long, unsigned char)+0x24>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:283
    strip.setPixelColor(i, c);
    strip.show();
    delay(wait);
  }
}
     a1c:	df 91       	pop	r29
     a1e:	cf 91       	pop	r28
     a20:	ff 90       	pop	r15
     a22:	ef 90       	pop	r14
     a24:	df 90       	pop	r13
     a26:	cf 90       	pop	r12
     a28:	bf 90       	pop	r11
     a2a:	af 90       	pop	r10
     a2c:	9f 90       	pop	r9
     a2e:	8f 90       	pop	r8
     a30:	08 95       	ret

00000a32 <UartClass::begin(unsigned long)>:
_ZN9UartClass5beginEm():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.h:175
  public:
    inline UartClass(volatile USART_t *hwserial_module, uint8_t hwserial_rx_pin, uint8_t hwserial_tx_pin, uint8_t hwserial_rx_pin_swap, uint8_t hwserial_tx_pin_swap, uint8_t dre_vect_num, uint8_t uart_mux, uint8_t uart_mux_swap);
    bool pins(uint8_t tx, uint8_t rx);
    bool swap(uint8_t state = 1);
    void begin(unsigned long baud) {
      begin(baud, SERIAL_8N1);
     a32:	dc 01       	movw	r26, r24
     a34:	ed 91       	ld	r30, X+
     a36:	fc 91       	ld	r31, X
     a38:	06 84       	ldd	r0, Z+14	; 0x0e
     a3a:	f7 85       	ldd	r31, Z+15	; 0x0f
     a3c:	e0 2d       	mov	r30, r0
     a3e:	23 e0       	ldi	r18, 0x03	; 3
     a40:	30 e0       	ldi	r19, 0x00	; 0
     a42:	09 94       	ijmp

00000a44 <Print::write(char const*) [clone .part.2] [clone .constprop.30]>:
_ZN5Print5writeEPKc.part.2.constprop.30():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore\api/Print.h:56
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) {
        return 0;
      }
      return write((const uint8_t *)str, strlen(str));
     a44:	fc 01       	movw	r30, r24
     a46:	01 90       	ld	r0, Z+
     a48:	00 20       	and	r0, r0
     a4a:	e9 f7       	brne	.-6      	; 0xa46 <Print::write(char const*) [clone .part.2] [clone .constprop.30]+0x2>
     a4c:	31 97       	sbiw	r30, 0x01	; 1
     a4e:	af 01       	movw	r20, r30
     a50:	48 1b       	sub	r20, r24
     a52:	59 0b       	sbc	r21, r25
     a54:	bc 01       	movw	r22, r24
     a56:	82 e8       	ldi	r24, 0x82	; 130
     a58:	99 e3       	ldi	r25, 0x39	; 57
     a5a:	0c 94 e7 02 	jmp	0x5ce	; 0x5ce <Print::write(unsigned char const*, unsigned int)>

00000a5e <digitalRead>:
digitalRead():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:32
#include "pins_arduino.h"


inline __attribute__((always_inline)) void check_valid_digital_pin(pin_size_t pin)
{
  if(__builtin_constant_p(pin))
     a5e:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:301
}

int8_t digitalRead(uint8_t pin) {
  check_valid_digital_pin(pin);
  /* Get bit mask and check valid pin */
  uint8_t bit_mask = digitalPinToBitMask(pin);
     a60:	fc 01       	movw	r30, r24
     a62:	e8 5b       	subi	r30, 0xB8	; 184
     a64:	f5 46       	sbci	r31, 0x65	; 101
     a66:	20 81       	ld	r18, Z
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:302
  if (bit_mask == NOT_A_PIN) {
     a68:	2f 3f       	cpi	r18, 0xFF	; 255
     a6a:	79 f0       	breq	.+30     	; 0xa8a <digitalRead+0x2c>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:315
  // high bar for stuff that would make it even slower than it already is.
  //
  // turnOffPWM(pin);

  /* Get port and check valid port */
  PORT_t *port = digitalPinToPortStruct(pin);
     a6c:	8c 5a       	subi	r24, 0xAC	; 172
     a6e:	95 46       	sbci	r25, 0x65	; 101
     a70:	dc 01       	movw	r26, r24
     a72:	ec 91       	ld	r30, X
     a74:	b0 e2       	ldi	r27, 0x20	; 32
     a76:	eb 9f       	mul	r30, r27
     a78:	f0 01       	movw	r30, r0
     a7a:	11 24       	eor	r1, r1
     a7c:	fc 5f       	subi	r31, 0xFC	; 252
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:318

  /* Read pin value from PORTx.IN register */
  if (port->IN & bit_mask) {
     a7e:	90 85       	ldd	r25, Z+8	; 0x08
     a80:	92 23       	and	r25, r18
     a82:	81 e0       	ldi	r24, 0x01	; 1
     a84:	19 f4       	brne	.+6      	; 0xa8c <digitalRead+0x2e>
     a86:	80 e0       	ldi	r24, 0x00	; 0
     a88:	08 95       	ret
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:303
int8_t digitalRead(uint8_t pin) {
  check_valid_digital_pin(pin);
  /* Get bit mask and check valid pin */
  uint8_t bit_mask = digitalPinToBitMask(pin);
  if (bit_mask == NOT_A_PIN) {
    return -1;
     a8a:	8f ef       	ldi	r24, 0xFF	; 255
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:323
  if (port->IN & bit_mask) {
    return HIGH;
  } else {
    return LOW;
  }
}
     a8c:	08 95       	ret

00000a8e <digitalWrite>:
digitalWrite():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:32
#include "pins_arduino.h"


inline __attribute__((always_inline)) void check_valid_digital_pin(pin_size_t pin)
{
  if(__builtin_constant_p(pin))
     a8e:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:198


void digitalWrite(uint8_t pin, uint8_t val) {
  check_valid_digital_pin(pin);
  /* Get bit mask for pin */
  uint8_t bit_mask = digitalPinToBitMask(pin);
     a90:	fc 01       	movw	r30, r24
     a92:	e8 5b       	subi	r30, 0xB8	; 184
     a94:	f5 46       	sbci	r31, 0x65	; 101
     a96:	20 81       	ld	r18, Z
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:199
  if (bit_mask == NOT_A_PIN) {
     a98:	2f 3f       	cpi	r18, 0xFF	; 255
     a9a:	09 f4       	brne	.+2      	; 0xa9e <digitalWrite+0x10>
     a9c:	69 c0       	rjmp	.+210    	; 0xb70 <digitalWrite+0xe2>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:204
    return;
  }

  /* Get port */
  PORT_t *port = digitalPinToPortStruct(pin);
     a9e:	fc 01       	movw	r30, r24
     aa0:	ec 5a       	subi	r30, 0xAC	; 172
     aa2:	f5 46       	sbci	r31, 0x65	; 101
     aa4:	e0 81       	ld	r30, Z
     aa6:	30 e2       	ldi	r19, 0x20	; 32
     aa8:	e3 9f       	mul	r30, r19
     aaa:	f0 01       	movw	r30, r0
     aac:	11 24       	eor	r1, r1
     aae:	fc 5f       	subi	r31, 0xFC	; 252
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:216
  you could digitalWrite() a pin while it's an input, to ensure
  that the value of the port was set correctly when it was
  changed to an output. Code in the wild relies on this behavior.
  */

  if (val == LOW) { /* If LOW */
     ab0:	61 11       	cpse	r22, r1
     ab2:	23 c0       	rjmp	.+70     	; 0xafa <digitalWrite+0x6c>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:217
    port->OUTCLR = bit_mask;
     ab4:	26 83       	std	Z+6, r18	; 0x06
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:234
  } else {
    port->OUTSET = bit_mask;
  }

  /* Input direction */
  if (!(port->DIR & bit_mask)) {
     ab6:	30 81       	ld	r19, Z
     ab8:	23 23       	and	r18, r19
     aba:	99 f4       	brne	.+38     	; 0xae2 <digitalWrite+0x54>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:241
      pull up is enabled if this function is called.
      Should we purposely implement this side effect?
    */

    /* Get bit position for getting pin ctrl reg */
    uint8_t bit_pos = digitalPinToBitPosition(pin);
     abc:	dc 01       	movw	r26, r24
     abe:	ae 5e       	subi	r26, 0xEE	; 238
     ac0:	b5 46       	sbci	r27, 0x65	; 101
     ac2:	2c 91       	ld	r18, X
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:244

    /* Calculate where pin control register is */
    volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(port, bit_pos);
     ac4:	30 97       	sbiw	r30, 0x00	; 0
     ac6:	d9 f0       	breq	.+54     	; 0xafe <digitalWrite+0x70>
     ac8:	2f 3f       	cpi	r18, 0xFF	; 255
     aca:	c9 f0       	breq	.+50     	; 0xafe <digitalWrite+0x70>
     acc:	70 96       	adiw	r30, 0x10	; 16
     ace:	e2 0f       	add	r30, r18
     ad0:	f1 1d       	adc	r31, r1
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:247

    /* Save system status and disable interrupts */
    uint8_t status = SREG;
     ad2:	3f b7       	in	r19, 0x3f	; 63
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:248
    cli();
     ad4:	f8 94       	cli
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:252

    if (val == LOW) {
      /* Disable pullup */
      *pin_ctrl_reg &= ~PORT_PULLUPEN_bm;
     ad6:	20 81       	ld	r18, Z
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:250

    /* Save system status and disable interrupts */
    uint8_t status = SREG;
    cli();

    if (val == LOW) {
     ad8:	61 11       	cpse	r22, r1
     ada:	14 c0       	rjmp	.+40     	; 0xb04 <digitalWrite+0x76>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:252
      /* Disable pullup */
      *pin_ctrl_reg &= ~PORT_PULLUPEN_bm;
     adc:	27 7f       	andi	r18, 0xF7	; 247
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:255
    } else {
      /* Enable pull-up */
      *pin_ctrl_reg |= PORT_PULLUPEN_bm;
     ade:	20 83       	st	Z, r18
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:259
    }

    /* Restore system status */
    SREG = status;
     ae0:	3f bf       	out	0x3f, r19	; 63
turnOffPWM():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:113
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t pin) {
  /* Actually turn off compare channel, not the timer */

  /* Get pin's timer */
  uint8_t timer = digitalPinToTimer(pin);
     ae2:	fc 01       	movw	r30, r24
     ae4:	ea 5f       	subi	r30, 0xFA	; 250
     ae6:	f5 46       	sbci	r31, 0x65	; 101
     ae8:	20 81       	ld	r18, Z
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:114
  if (timer == NOT_ON_TIMER) {
     aea:	22 23       	and	r18, r18
     aec:	09 f4       	brne	.+2      	; 0xaf0 <digitalWrite+0x62>
     aee:	40 c0       	rjmp	.+128    	; 0xb70 <digitalWrite+0xe2>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:121
  }

  uint8_t bit_pos = digitalPinToBitPosition(pin);
  //TCB_t *timerB;

  switch (timer) {
     af0:	20 31       	cpi	r18, 0x10	; 16
     af2:	51 f0       	breq	.+20     	; 0xb08 <digitalWrite+0x7a>
     af4:	20 38       	cpi	r18, 0x80	; 128
     af6:	d1 f1       	breq	.+116    	; 0xb6c <digitalWrite+0xde>
     af8:	08 95       	ret
digitalWrite():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:230
    // val will now be 0 (LOW) if the toggling made it LOW
    // or bit_mask if not. And further down, we only need to
    // know if it's
  /* If HIGH OR  > TOGGLE  */
  } else {
    port->OUTSET = bit_mask;
     afa:	25 83       	std	Z+5, r18	; 0x05
     afc:	dc cf       	rjmp	.-72     	; 0xab6 <digitalWrite+0x28>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:244

    /* Get bit position for getting pin ctrl reg */
    uint8_t bit_pos = digitalPinToBitPosition(pin);

    /* Calculate where pin control register is */
    volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(port, bit_pos);
     afe:	f0 e0       	ldi	r31, 0x00	; 0
     b00:	e0 e0       	ldi	r30, 0x00	; 0
     b02:	e7 cf       	rjmp	.-50     	; 0xad2 <digitalWrite+0x44>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:255
    if (val == LOW) {
      /* Disable pullup */
      *pin_ctrl_reg &= ~PORT_PULLUPEN_bm;
    } else {
      /* Enable pull-up */
      *pin_ctrl_reg |= PORT_PULLUPEN_bm;
     b04:	28 60       	ori	r18, 0x08	; 8
     b06:	eb cf       	rjmp	.-42     	; 0xade <digitalWrite+0x50>
turnOffPWM():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:118
  uint8_t timer = digitalPinToTimer(pin);
  if (timer == NOT_ON_TIMER) {
    return;
  }

  uint8_t bit_pos = digitalPinToBitPosition(pin);
     b08:	8e 5e       	subi	r24, 0xEE	; 238
     b0a:	95 46       	sbci	r25, 0x65	; 101
     b0c:	fc 01       	movw	r30, r24
     b0e:	80 81       	ld	r24, Z
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:133
      #ifdef __AVR_ATtinyxy2__
        if (bit_pos == 7) {
          bit_pos = 0;  //on the xy2, WO0 is on PA7
        }
      #endif
        if (bit_pos > 2) {
     b10:	83 30       	cpi	r24, 0x03	; 3
     b12:	c8 f0       	brcs	.+50     	; 0xb46 <digitalWrite+0xb8>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:134
          bit_pos -= 3;
     b14:	83 50       	subi	r24, 0x03	; 3
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:135
          timer_cmp_out = ((uint8_t *)(&TCA0.SPLIT.HCMP0)) + (bit_pos << 1);
     b16:	90 e0       	ldi	r25, 0x00	; 0
     b18:	fc 01       	movw	r30, r24
     b1a:	ee 0f       	add	r30, r30
     b1c:	ff 1f       	adc	r31, r31
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:136
          (*timer_cmp_out) = 0;
     b1e:	e7 5d       	subi	r30, 0xD7	; 215
     b20:	f5 4f       	sbci	r31, 0xF5	; 245
     b22:	10 82       	st	Z, r1
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:137
          TCA0.SPLIT.CTRLB &= ~(1 << (TCA_SPLIT_HCMP0EN_bp + bit_pos));
     b24:	40 91 01 0a 	lds	r20, 0x0A01	; 0x800a01 <digital_pin_to_port+0x7f6fad>
     b28:	04 96       	adiw	r24, 0x04	; 4
     b2a:	21 e0       	ldi	r18, 0x01	; 1
     b2c:	30 e0       	ldi	r19, 0x00	; 0
     b2e:	b9 01       	movw	r22, r18
     b30:	02 c0       	rjmp	.+4      	; 0xb36 <digitalWrite+0xa8>
     b32:	66 0f       	add	r22, r22
     b34:	77 1f       	adc	r23, r23
     b36:	8a 95       	dec	r24
     b38:	e2 f7       	brpl	.-8      	; 0xb32 <digitalWrite+0xa4>
     b3a:	cb 01       	movw	r24, r22
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:141
        } else {
          timer_cmp_out = ((uint8_t *)(&TCA0.SPLIT.LCMP0)) + (bit_pos << 1);
          (*timer_cmp_out) = 0;
          TCA0.SPLIT.CTRLB &= ~(1 << (TCA_SPLIT_LCMP0EN_bp + bit_pos));
     b3c:	80 95       	com	r24
     b3e:	84 23       	and	r24, r20
     b40:	80 93 01 0a 	sts	0x0A01, r24	; 0x800a01 <digital_pin_to_port+0x7f6fad>
     b44:	08 95       	ret
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:139
          bit_pos -= 3;
          timer_cmp_out = ((uint8_t *)(&TCA0.SPLIT.HCMP0)) + (bit_pos << 1);
          (*timer_cmp_out) = 0;
          TCA0.SPLIT.CTRLB &= ~(1 << (TCA_SPLIT_HCMP0EN_bp + bit_pos));
        } else {
          timer_cmp_out = ((uint8_t *)(&TCA0.SPLIT.LCMP0)) + (bit_pos << 1);
     b46:	e8 2f       	mov	r30, r24
     b48:	f0 e0       	ldi	r31, 0x00	; 0
     b4a:	ee 0f       	add	r30, r30
     b4c:	ff 1f       	adc	r31, r31
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:140
          (*timer_cmp_out) = 0;
     b4e:	e8 5d       	subi	r30, 0xD8	; 216
     b50:	f5 4f       	sbci	r31, 0xF5	; 245
     b52:	10 82       	st	Z, r1
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:141
          TCA0.SPLIT.CTRLB &= ~(1 << (TCA_SPLIT_LCMP0EN_bp + bit_pos));
     b54:	40 91 01 0a 	lds	r20, 0x0A01	; 0x800a01 <digital_pin_to_port+0x7f6fad>
     b58:	21 e0       	ldi	r18, 0x01	; 1
     b5a:	30 e0       	ldi	r19, 0x00	; 0
     b5c:	f9 01       	movw	r30, r18
     b5e:	02 c0       	rjmp	.+4      	; 0xb64 <digitalWrite+0xd6>
     b60:	ee 0f       	add	r30, r30
     b62:	ff 1f       	adc	r31, r31
     b64:	8a 95       	dec	r24
     b66:	e2 f7       	brpl	.-8      	; 0xb60 <digitalWrite+0xd2>
     b68:	cf 01       	movw	r24, r30
     b6a:	e8 cf       	rjmp	.-48     	; 0xb3c <digitalWrite+0xae>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:151
      /* we don't need the type b timers as this core does not use them for PWM      */

    // 1-series parts have a DAC that we can use...
    #if defined(DAC0)
      case DACOUT:
        DAC0.CTRLA = 0x00;
     b6c:	10 92 a0 06 	sts	0x06A0, r1	; 0x8006a0 <digital_pin_to_port+0x7f6c4c>
digitalWrite():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:266
  /* Turn off PWM if applicable */
  // If the pin supports PWM output, we need to turn it off
  // Better to do so AFTER we have set PORTx.OUT to what we want it to be when we're done
  // The glitch would be super short, of course, but why make a glitch we don't have to?
  turnOffPWM(pin);
}
     b70:	08 95       	ret

00000b72 <pinMode>:
pinMode():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:41
    // taking shortcuts we disapprove of, but to call out things that are virtually guaranteed to be a bug.
    // Passing -1/255/NOT_A_PIN to the digital I/O functions is most likely intentional.
      badArg("Digital pin is constant, but not a valid pin");
}

void pinMode(uint8_t pin, uint8_t mode) {
     b72:	cf 93       	push	r28
     b74:	df 93       	push	r29
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:44
  check_valid_digital_pin(pin);

  uint8_t bit_mask = digitalPinToBitMask(pin);
     b76:	8c 30       	cpi	r24, 0x0C	; 12
     b78:	98 f4       	brcc	.+38     	; 0xba0 <pinMode+0x2e>
check_valid_digital_pin():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:32
#include "pins_arduino.h"


inline __attribute__((always_inline)) void check_valid_digital_pin(pin_size_t pin)
{
  if(__builtin_constant_p(pin))
     b7a:	90 e0       	ldi	r25, 0x00	; 0
pinMode():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:44
}

void pinMode(uint8_t pin, uint8_t mode) {
  check_valid_digital_pin(pin);

  uint8_t bit_mask = digitalPinToBitMask(pin);
     b7c:	fc 01       	movw	r30, r24
     b7e:	e8 5b       	subi	r30, 0xB8	; 184
     b80:	f5 46       	sbci	r31, 0x65	; 101
     b82:	20 81       	ld	r18, Z
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:46

  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
     b84:	2f 3f       	cpi	r18, 0xFF	; 255
     b86:	61 f0       	breq	.+24     	; 0xba0 <pinMode+0x2e>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:50
    return;
  }

  PORT_t *port = digitalPinToPortStruct(pin);
     b88:	fc 01       	movw	r30, r24
     b8a:	ec 5a       	subi	r30, 0xAC	; 172
     b8c:	f5 46       	sbci	r31, 0x65	; 101
     b8e:	e0 81       	ld	r30, Z
     b90:	30 e2       	ldi	r19, 0x20	; 32
     b92:	e3 9f       	mul	r30, r19
     b94:	f0 01       	movw	r30, r0
     b96:	11 24       	eor	r1, r1
     b98:	fc 5f       	subi	r31, 0xFC	; 252
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:55
  if (port == NULL) {
    return;
  }

  if (mode == OUTPUT) {
     b9a:	61 30       	cpi	r22, 0x01	; 1
     b9c:	21 f4       	brne	.+8      	; 0xba6 <pinMode+0x34>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:58

    /* Configure direction as output */
    port->DIRSET = bit_mask;
     b9e:	21 83       	std	Z+1, r18	; 0x01
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:93
    }

    /* Restore state */
    SREG = status;
  }
}
     ba0:	df 91       	pop	r29
     ba2:	cf 91       	pop	r28
     ba4:	08 95       	ret
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:62
    /* Configure direction as output */
    port->DIRSET = bit_mask;

  } else { /* mode == INPUT or INPUT_PULLUP */

    uint8_t bit_pos = digitalPinToBitPosition(pin);
     ba6:	8e 5e       	subi	r24, 0xEE	; 238
     ba8:	95 46       	sbci	r25, 0x65	; 101
     baa:	ec 01       	movw	r28, r24
     bac:	a8 81       	ld	r26, Y
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:64
    /* Calculate where pin control register is */
    volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(port, bit_pos);
     bae:	af 3f       	cpi	r26, 0xFF	; 255
     bb0:	81 f0       	breq	.+32     	; 0xbd2 <pinMode+0x60>
     bb2:	cf 01       	movw	r24, r30
     bb4:	40 96       	adiw	r24, 0x10	; 16
     bb6:	a8 0f       	add	r26, r24
     bb8:	b9 2f       	mov	r27, r25
     bba:	b1 1d       	adc	r27, r1
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:67

    /* Save state */
    uint8_t status = SREG;
     bbc:	9f b7       	in	r25, 0x3f	; 63
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:68
    cli();
     bbe:	f8 94       	cli
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:71

    /* Configure direction as input */
    port->DIRCLR = bit_mask;
     bc0:	22 83       	std	Z+2, r18	; 0x02
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:77

    /* Configure pull-up resistor */
    if (mode == INPUT_PULLUP) {

      /* Enable pull-up */
      *pin_ctrl_reg |= PORT_PULLUPEN_bm;
     bc2:	8c 91       	ld	r24, X
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:74

    /* Configure direction as input */
    port->DIRCLR = bit_mask;

    /* Configure pull-up resistor */
    if (mode == INPUT_PULLUP) {
     bc4:	62 30       	cpi	r22, 0x02	; 2
     bc6:	41 f4       	brne	.+16     	; 0xbd8 <pinMode+0x66>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:77

      /* Enable pull-up */
      *pin_ctrl_reg |= PORT_PULLUPEN_bm;
     bc8:	88 60       	ori	r24, 0x08	; 8
     bca:	8c 93       	st	X, r24
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:79
      // emulate setting of the port output register on classic AVR
      port->OUTSET=bit_mask;
     bcc:	25 83       	std	Z+5, r18	; 0x05
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:91
      port->OUTCLR=bit_mask;

    }

    /* Restore state */
    SREG = status;
     bce:	9f bf       	out	0x3f, r25	; 63
     bd0:	e7 cf       	rjmp	.-50     	; 0xba0 <pinMode+0x2e>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:64

  } else { /* mode == INPUT or INPUT_PULLUP */

    uint8_t bit_pos = digitalPinToBitPosition(pin);
    /* Calculate where pin control register is */
    volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(port, bit_pos);
     bd2:	b0 e0       	ldi	r27, 0x00	; 0
     bd4:	a0 e0       	ldi	r26, 0x00	; 0
     bd6:	f2 cf       	rjmp	.-28     	; 0xbbc <pinMode+0x4a>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:84
      port->OUTSET=bit_mask;

    } else { /* mode == INPUT (no pullup) */

      /* Disable pull-up */
      *pin_ctrl_reg &= ~(PORT_PULLUPEN_bm);
     bd8:	87 7f       	andi	r24, 0xF7	; 247
     bda:	8c 93       	st	X, r24
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_digital.c:86
      // emulate setting of the port output register on classic AVR
      port->OUTCLR=bit_mask;
     bdc:	26 83       	std	Z+6, r18	; 0x06
     bde:	f7 cf       	rjmp	.-18     	; 0xbce <pinMode+0x5c>

00000be0 <analogWrite.constprop.21>:
analogWrite.constprop.21():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_analog.c:191

// Right now, PWM output only works on the pins with
// hardware support.  These are defined in the appropriate
// pins_*.c file.  For the rest of the pins, we default
// to digital output.
void analogWrite(uint8_t pin, int val) {
     be0:	cf 93       	push	r28
     be2:	df 93       	push	r29
     be4:	ec 01       	movw	r28, r24
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_analog.c:199
  uint8_t bit_pos  = digitalPinToBitPosition(pin);
  if (bit_pos == NOT_A_PIN) {
    return;
  }
  // Set pin output because that's what Arduino does
  pinMode(pin, OUTPUT);
     be6:	61 e0       	ldi	r22, 0x01	; 1
     be8:	80 e0       	ldi	r24, 0x00	; 0
     bea:	0e 94 b9 05 	call	0xb72	; 0xb72 <pinMode>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_analog.c:208
  uint8_t *timer_cmp_out;
  /* Find out Port and Pin to correctly handle port mux, and timer. */
  switch (digital_pin_timer) {
    case TIMERA0:
      if (val <= 0) { /* if zero or negative drive digital low */
        digitalWrite(pin, LOW);
     bee:	60 e0       	ldi	r22, 0x00	; 0
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_analog.c:207
  uint8_t digital_pin_timer =  digitalPinToTimer(pin);
  uint8_t *timer_cmp_out;
  /* Find out Port and Pin to correctly handle port mux, and timer. */
  switch (digital_pin_timer) {
    case TIMERA0:
      if (val <= 0) { /* if zero or negative drive digital low */
     bf0:	20 97       	sbiw	r28, 0x00	; 0
     bf2:	21 f0       	breq	.+8      	; 0xbfc <analogWrite.constprop.21+0x1c>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_analog.c:209
        digitalWrite(pin, LOW);
      } else if (val >= 255) { /* if max or greater drive digital high */
     bf4:	cf 3f       	cpi	r28, 0xFF	; 255
     bf6:	d1 05       	cpc	r29, r1
     bf8:	31 f4       	brne	.+12     	; 0xc06 <analogWrite.constprop.21+0x26>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_analog.c:210
        digitalWrite(pin, HIGH);
     bfa:	61 e0       	ldi	r22, 0x01	; 1
     bfc:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_analog.c:326
      } else {
        digitalWrite(pin, HIGH);
      }
      break;
  } //end of switch/case
} // end of analogWrite
     bfe:	df 91       	pop	r29
     c00:	cf 91       	pop	r28
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_analog.c:210
  switch (digital_pin_timer) {
    case TIMERA0:
      if (val <= 0) { /* if zero or negative drive digital low */
        digitalWrite(pin, LOW);
      } else if (val >= 255) { /* if max or greater drive digital high */
        digitalWrite(pin, HIGH);
     c02:	0c 94 47 05 	jmp	0xa8e	; 0xa8e <digitalWrite>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_analog.c:221
        }
        #endif
        if (bit_pos > 2) {
          bit_pos -= 3;
          timer_cmp_out = ((uint8_t *)(&TCA0.SPLIT.HCMP0)) + (bit_pos << 1);
          (*timer_cmp_out) = (val);
     c06:	c0 93 2b 0a 	sts	0x0A2B, r28	; 0x800a2b <digital_pin_to_port+0x7f6fd7>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_analog.c:222
          TCA0.SPLIT.CTRLB |= (1 << (TCA_SPLIT_HCMP0EN_bp + bit_pos));
     c0a:	80 91 01 0a 	lds	r24, 0x0A01	; 0x800a01 <digital_pin_to_port+0x7f6fad>
     c0e:	80 62       	ori	r24, 0x20	; 32
     c10:	80 93 01 0a 	sts	0x0A01, r24	; 0x800a01 <digital_pin_to_port+0x7f6fad>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring_analog.c:326
      } else {
        digitalWrite(pin, HIGH);
      }
      break;
  } //end of switch/case
} // end of analogWrite
     c14:	df 91       	pop	r29
     c16:	cf 91       	pop	r28
     c18:	08 95       	ret

00000c1a <receiveEvent(int)>:
_Z12receiveEventi():
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:459
 *                5 state to set 
 *          101...  12 bytes for colors
 *                  
 **/

void receiveEvent(int howMany) {
     c1a:	1f 93       	push	r17
     c1c:	cf 93       	push	r28
     c1e:	df 93       	push	r29
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:460
  readBuffer = true;
     c20:	21 e0       	ldi	r18, 0x01	; 1
     c22:	20 93 01 38 	sts	0x3801, r18	; 0x803801 <readBuffer>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:468
  lastNumItems = howMany;

  /**
   * if how many, then requesting a read, else read pixel values
   */
  if(howMany == 1){
     c26:	01 97       	sbiw	r24, 0x01	; 1
     c28:	89 f4       	brne	.+34     	; 0xc4c <receiveEvent(int)+0x32>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:469
    reg = Wire.read();
     c2a:	8d e1       	ldi	r24, 0x1D	; 29
     c2c:	9a e3       	ldi	r25, 0x3A	; 58
     c2e:	0e 94 45 04 	call	0x88a	; 0x88a <TwoWire::read()>
     c32:	80 93 02 38 	sts	0x3802, r24	; 0x803802 <reg>
write():
     c36:	80 e6       	ldi	r24, 0x60	; 96
     c38:	9a e9       	ldi	r25, 0x9A	; 154
     c3a:	0e 94 22 05 	call	0xa44	; 0xa44 <Print::write(char const*) [clone .part.2] [clone .constprop.30]>
     c3e:	88 e6       	ldi	r24, 0x68	; 104
     c40:	9a e9       	ldi	r25, 0x9A	; 154
_Z12receiveEventi():
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:518
        digitalWrite(TPU_RST_L, LOW);
      }
    }    
    nextState = true;
  }
}
     c42:	df 91       	pop	r29
     c44:	cf 91       	pop	r28
     c46:	1f 91       	pop	r17
write():
     c48:	0c 94 22 05 	jmp	0xa44	; 0xa44 <Print::write(char const*) [clone .part.2] [clone .constprop.30]>
_Z12receiveEventi():
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:474
    reg = Wire.read();
    //Serial.println(reg, HEX );
    Serial.println("Reading" );
  }
  else{
    addrStart     = Wire.read() ; // first byte is pixel address or command
     c4c:	8d e1       	ldi	r24, 0x1D	; 29
     c4e:	9a e3       	ldi	r25, 0x3A	; 58
     c50:	0e 94 45 04 	call	0x88a	; 0x88a <TwoWire::read()>
     c54:	18 2f       	mov	r17, r24
     c56:	80 93 00 38 	sts	0x3800, r24	; 0x803800 <__DATA_REGION_ORIGIN__>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:479
    
    if(addrStart < NUMPIXELS) {
      while (1 <= Wire.available()) { // loop through all but the last
        byte c = Wire.read(); // receive byte as a character
        bufferI2C[addrStart * 3 + i] = c;
     c5a:	99 27       	eor	r25, r25
     c5c:	ec 01       	movw	r28, r24
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:476
    Serial.println("Reading" );
  }
  else{
    addrStart     = Wire.read() ; // first byte is pixel address or command
    
    if(addrStart < NUMPIXELS) {
     c5e:	1c 30       	cpi	r17, 0x0C	; 12
     c60:	90 f0       	brcs	.+36     	; 0xc86 <receiveEvent(int)+0x6c>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:487
      setState(1);
    }
    else  {
      while (1 <= Wire.available()) { // loop through all but the last
        byte c = Wire.read(); // receive byte as a character
        bufferI2C[addrStart ] = c; 
     c62:	c4 58       	subi	r28, 0x84	; 132
     c64:	d7 4c       	sbci	r29, 0xC7	; 199
available():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src/Wire.cpp:306

// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::available(void) {
  return rxBufferLength - rxBufferIndex;
     c66:	80 91 64 38 	lds	r24, 0x3864	; 0x803864 <TwoWire::rxBufferLength>
     c6a:	90 91 65 38 	lds	r25, 0x3865	; 0x803865 <TwoWire::rxBufferIndex>
     c6e:	89 1b       	sub	r24, r25
     c70:	99 0b       	sbc	r25, r25
_Z12receiveEventi():
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:485
        i++;
      }
      setState(1);
    }
    else  {
      while (1 <= Wire.available()) { // loop through all but the last
     c72:	18 16       	cp	r1, r24
     c74:	19 06       	cpc	r1, r25
     c76:	0c f0       	brlt	.+2      	; 0xc7a <receiveEvent(int)+0x60>
     c78:	4d c0       	rjmp	.+154    	; 0xd14 <receiveEvent(int)+0xfa>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:486
        byte c = Wire.read(); // receive byte as a character
     c7a:	8d e1       	ldi	r24, 0x1D	; 29
     c7c:	9a e3       	ldi	r25, 0x3A	; 58
     c7e:	0e 94 45 04 	call	0x88a	; 0x88a <TwoWire::read()>
     c82:	88 83       	st	Y, r24
     c84:	f0 cf       	rjmp	.-32     	; 0xc66 <receiveEvent(int)+0x4c>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:479
    addrStart     = Wire.read() ; // first byte is pixel address or command
    
    if(addrStart < NUMPIXELS) {
      while (1 <= Wire.available()) { // loop through all but the last
        byte c = Wire.read(); // receive byte as a character
        bufferI2C[addrStart * 3 + i] = c;
     c86:	cc 0f       	add	r28, r28
     c88:	dd 1f       	adc	r29, r29
     c8a:	c8 0f       	add	r28, r24
     c8c:	d9 1f       	adc	r29, r25
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:461
 *                  
 **/

void receiveEvent(int howMany) {
  readBuffer = true;
  byte i = 0;
     c8e:	10 e0       	ldi	r17, 0x00	; 0
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:479
    addrStart     = Wire.read() ; // first byte is pixel address or command
    
    if(addrStart < NUMPIXELS) {
      while (1 <= Wire.available()) { // loop through all but the last
        byte c = Wire.read(); // receive byte as a character
        bufferI2C[addrStart * 3 + i] = c;
     c90:	c4 58       	subi	r28, 0x84	; 132
     c92:	d7 4c       	sbci	r29, 0xC7	; 199
available():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src/Wire.cpp:306
     c94:	80 91 64 38 	lds	r24, 0x3864	; 0x803864 <TwoWire::rxBufferLength>
     c98:	90 91 65 38 	lds	r25, 0x3865	; 0x803865 <TwoWire::rxBufferIndex>
     c9c:	89 1b       	sub	r24, r25
     c9e:	99 0b       	sbc	r25, r25
_Z12receiveEventi():
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:477
  }
  else{
    addrStart     = Wire.read() ; // first byte is pixel address or command
    
    if(addrStart < NUMPIXELS) {
      while (1 <= Wire.available()) { // loop through all but the last
     ca0:	18 16       	cp	r1, r24
     ca2:	19 06       	cpc	r1, r25
     ca4:	54 f4       	brge	.+20     	; 0xcba <receiveEvent(int)+0xa0>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:478
        byte c = Wire.read(); // receive byte as a character
     ca6:	8d e1       	ldi	r24, 0x1D	; 29
     ca8:	9a e3       	ldi	r25, 0x3A	; 58
     caa:	0e 94 45 04 	call	0x88a	; 0x88a <TwoWire::read()>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:479
        bufferI2C[addrStart * 3 + i] = c;
     cae:	fe 01       	movw	r30, r28
     cb0:	e1 0f       	add	r30, r17
     cb2:	f1 1d       	adc	r31, r1
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:478
  else{
    addrStart     = Wire.read() ; // first byte is pixel address or command
    
    if(addrStart < NUMPIXELS) {
      while (1 <= Wire.available()) { // loop through all but the last
        byte c = Wire.read(); // receive byte as a character
     cb4:	80 83       	st	Z, r24
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:480
        bufferI2C[addrStart * 3 + i] = c;
        i++;
     cb6:	1f 5f       	subi	r17, 0xFF	; 255
     cb8:	ed cf       	rjmp	.-38     	; 0xc94 <receiveEvent(int)+0x7a>
setState():
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:245
  // invert input so 255 is full on, zero is off
  analogWrite(FAN_PWM, constrain(255 - fanSpeed, 0, 255));

}
inline void setState(byte s1){
  state = s1;
     cba:	81 e0       	ldi	r24, 0x01	; 1
     cbc:	80 93 81 39 	sts	0x3981, r24	; 0x803981 <state>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:246
  if(state > MAXSTATES){
     cc0:	80 91 81 39 	lds	r24, 0x3981	; 0x803981 <state>
     cc4:	8b 30       	cpi	r24, 0x0B	; 11
     cc6:	18 f0       	brcs	.+6      	; 0xcce <receiveEvent(int)+0xb4>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:247
      state = MAXSTATES;
     cc8:	8a e0       	ldi	r24, 0x0A	; 10
     cca:	80 93 81 39 	sts	0x3981, r24	; 0x803981 <state>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:250
   }
   //nextState = true;
   readBuffer = false;
     cce:	10 92 01 38 	sts	0x3801, r1	; 0x803801 <readBuffer>
_Z12receiveEventi():
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:500
      setFan(fanSpeed);  
    }
    /**
     * Set the Enable TPU
     */
    if (addrStart == 0x52){
     cd2:	80 91 00 38 	lds	r24, 0x3800	; 0x803800 <__DATA_REGION_ORIGIN__>
     cd6:	82 35       	cpi	r24, 0x52	; 82
     cd8:	49 f4       	brne	.+18     	; 0xcec <receiveEvent(int)+0xd2>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:501
      if(bufferI2C[0x52] == 1){
     cda:	80 91 ce 38 	lds	r24, 0x38CE	; 0x8038ce <bufferI2C+0x52>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:502
        digitalWrite(TPU_PMIC_EN, HIGH);
     cde:	61 e0       	ldi	r22, 0x01	; 1
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:501
    }
    /**
     * Set the Enable TPU
     */
    if (addrStart == 0x52){
      if(bufferI2C[0x52] == 1){
     ce0:	81 30       	cpi	r24, 0x01	; 1
     ce2:	09 f0       	breq	.+2      	; 0xce6 <receiveEvent(int)+0xcc>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:505
        digitalWrite(TPU_PMIC_EN, HIGH);
      }
      else{
        digitalWrite(TPU_PMIC_EN, LOW);
     ce4:	60 e0       	ldi	r22, 0x00	; 0
     ce6:	82 e0       	ldi	r24, 0x02	; 2
     ce8:	0e 94 47 05 	call	0xa8e	; 0xa8e <digitalWrite>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:508
      }
    }
    if (addrStart == 0x53){
     cec:	80 91 00 38 	lds	r24, 0x3800	; 0x803800 <__DATA_REGION_ORIGIN__>
     cf0:	83 35       	cpi	r24, 0x53	; 83
     cf2:	49 f4       	brne	.+18     	; 0xd06 <receiveEvent(int)+0xec>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:509
      if(bufferI2C[0x53] == 1){
     cf4:	80 91 cf 38 	lds	r24, 0x38CF	; 0x8038cf <bufferI2C+0x53>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:510
        digitalWrite(TPU_RST_L, HIGH);
     cf8:	61 e0       	ldi	r22, 0x01	; 1
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:509
      else{
        digitalWrite(TPU_PMIC_EN, LOW);
      }
    }
    if (addrStart == 0x53){
      if(bufferI2C[0x53] == 1){
     cfa:	81 30       	cpi	r24, 0x01	; 1
     cfc:	09 f0       	breq	.+2      	; 0xd00 <receiveEvent(int)+0xe6>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:513
        digitalWrite(TPU_RST_L, HIGH);
      }
      else{
        digitalWrite(TPU_RST_L, LOW);
     cfe:	60 e0       	ldi	r22, 0x00	; 0
     d00:	88 e0       	ldi	r24, 0x08	; 8
     d02:	0e 94 47 05 	call	0xa8e	; 0xa8e <digitalWrite>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:516
      }
    }    
    nextState = true;
     d06:	81 e0       	ldi	r24, 0x01	; 1
     d08:	80 93 80 39 	sts	0x3980, r24	; 0x803980 <nextState>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:518
  }
}
     d0c:	df 91       	pop	r29
     d0e:	cf 91       	pop	r28
     d10:	1f 91       	pop	r17
     d12:	08 95       	ret
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:492
        bufferI2C[addrStart ] = c; 
      }     
      //setState(addrStart - NUMPIXELS);
    }
    
    if (addrStart == 101){ //0x65
     d14:	15 36       	cpi	r17, 0x65	; 101
     d16:	e9 f6       	brne	.-70     	; 0xcd2 <receiveEvent(int)+0xb8>
setFan():
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:241
 */
void setFan(byte fanSpeed){

  // FAN_PWM at zero turns on Fan
  // invert input so 255 is full on, zero is off
  analogWrite(FAN_PWM, constrain(255 - fanSpeed, 0, 255));
     d18:	90 91 e1 38 	lds	r25, 0x38E1	; 0x8038e1 <bufferI2C+0x65>
     d1c:	2f ef       	ldi	r18, 0xFF	; 255
     d1e:	30 e0       	ldi	r19, 0x00	; 0
     d20:	a9 01       	movw	r20, r18
     d22:	49 1b       	sub	r20, r25
     d24:	51 09       	sbc	r21, r1
     d26:	ca 01       	movw	r24, r20
     d28:	0e 94 f0 05 	call	0xbe0	; 0xbe0 <analogWrite.constprop.21>
     d2c:	d2 cf       	rjmp	.-92     	; 0xcd2 <receiveEvent(int)+0xb8>

00000d2e <UartClass::begin(unsigned long, unsigned int)>:
_ZN9UartClass5beginEmj():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:172
    _pin_set = 0;
    return false;
  }
}

void UartClass::begin(unsigned long baud, uint16_t config) {
     d2e:	8f 92       	push	r8
     d30:	9f 92       	push	r9
     d32:	af 92       	push	r10
     d34:	bf 92       	push	r11
     d36:	df 92       	push	r13
     d38:	ef 92       	push	r14
     d3a:	ff 92       	push	r15
     d3c:	0f 93       	push	r16
     d3e:	1f 93       	push	r17
     d40:	cf 93       	push	r28
     d42:	df 93       	push	r29
     d44:	ec 01       	movw	r28, r24
     d46:	4a 01       	movw	r8, r20
     d48:	5b 01       	movw	r10, r22
     d4a:	d2 2e       	mov	r13, r18
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:179
    if (baud > (F_CPU/8)) badArg("Unachievable baud, too high - must be less than F_CPU/8");
    if (baud < (F_CPU/16800)) badArg("Unachievable baud, too low - must be more than F_CPU/16800 (16384 plus allowable error)");
  }
  // Make sure no transmissions are ongoing and USART is disabled in case begin() is called by accident
  // without first calling end()
  if (_written) {
     d4c:	8d 89       	ldd	r24, Y+21	; 0x15
     d4e:	88 23       	and	r24, r24
     d50:	39 f0       	breq	.+14     	; 0xd60 <UartClass::begin(unsigned long, unsigned int)+0x32>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:180
    this->end();
     d52:	e8 81       	ld	r30, Y
     d54:	f9 81       	ldd	r31, Y+1	; 0x01
     d56:	00 88       	ldd	r0, Z+16	; 0x10
     d58:	f1 89       	ldd	r31, Z+17	; 0x11
     d5a:	e0 2d       	mov	r30, r0
     d5c:	ce 01       	movw	r24, r28
     d5e:	09 95       	icall
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:183
  }

  struct UartPinSet *set = &_hw_set[_pin_set];
     d60:	0c 89       	ldd	r16, Y+20	; 0x14
     d62:	10 e0       	ldi	r17, 0x00	; 0
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:186

  int32_t baud_setting = 0;
  uint8_t rxmode=0;
     d64:	e1 2c       	mov	r14, r1
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:190

  // Use CLK2X if appropriate.
  #if (F_CPU > 2000000)
  if(baud>=(38400*(F_CPU/1000000))) {
     d66:	81 14       	cp	r8, r1
     d68:	28 eb       	ldi	r18, 0xB8	; 184
     d6a:	92 06       	cpc	r9, r18
     d6c:	2b e0       	ldi	r18, 0x0B	; 11
     d6e:	a2 06       	cpc	r10, r18
     d70:	b1 04       	cpc	r11, r1
     d72:	30 f0       	brcs	.+12     	; 0xd80 <UartClass::begin(unsigned long, unsigned int)+0x52>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:192
    rxmode = USART_RXMODE_CLK2X_gc;
    baud=baud>>1;
     d74:	b6 94       	lsr	r11
     d76:	a7 94       	ror	r10
     d78:	97 94       	ror	r9
     d7a:	87 94       	ror	r8
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:191
  uint8_t rxmode=0;

  // Use CLK2X if appropriate.
  #if (F_CPU > 2000000)
  if(baud>=(38400*(F_CPU/1000000))) {
    rxmode = USART_RXMODE_CLK2X_gc;
     d7c:	42 e0       	ldi	r20, 0x02	; 2
     d7e:	e4 2e       	mov	r14, r20
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:204
  #else
  //if clocked at 1 or 2 MHz, always use CLK2X mode and save a bit of space, we correct for not shifting the baud value below, as it saves a bit of flash
    rxmode = USART_RXMODE_CLK2X_gc;
  #endif

  _written = false;
     d80:	1d 8a       	std	Y+21, r1	; 0x15
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:214
  #if (CLOCK_SOURCE==0 && PROGMEM_SIZE > 4096 && (defined(UARTBAUD3V) || defined(UARTBAUD5V)))
    // if the flash is 2k or 4k, we really can't spare the flash for the baud rate correction...
    // it's close enough to work under normal circumstances anyway.
    #if (F_CPU==20000000UL || F_CPU==10000000UL || F_CPU==5000000UL) //this means we are on the 20MHz oscillator
      #ifdef UARTBAUD3V
        int8_t sigrow_val = SIGROW.OSC20ERR3V;
     d82:	f0 90 24 11 	lds	r15, 0x1124	; 0x801124 <digital_pin_to_port+0x7f76d0>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:227
        int8_t sigrow_val = SIGROW.OSC16ERR5V;
      #endif
    #endif
    #if (F_CPU > 2000000)
      //if we are above 2 MHz, baud was corrected above if CLK2X used.
      baud_setting = ((8 * F_CPU) / baud);
     d86:	60 e0       	ldi	r22, 0x00	; 0
     d88:	78 e6       	ldi	r23, 0x68	; 104
     d8a:	89 e8       	ldi	r24, 0x89	; 137
     d8c:	99 e0       	ldi	r25, 0x09	; 9
     d8e:	a5 01       	movw	r20, r10
     d90:	94 01       	movw	r18, r8
     d92:	0e 94 b7 0c 	call	0x196e	; 0x196e <__udivmodsi4>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:232
    #else
      //if clocked at 1 or 2 MHz, always use CLK2X mode and save a bit of flash...
      baud_setting = ((16 * F_CPU) / baud);
    #endif
    baud_setting *= (1024 + sigrow_val);
     d96:	af 2d       	mov	r26, r15
     d98:	ff 0c       	add	r15, r15
     d9a:	bb 0b       	sbc	r27, r27
     d9c:	bc 5f       	subi	r27, 0xFC	; 252
     d9e:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <__mulshisi3>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:233
    baud_setting /= 2048;
     da2:	dc 01       	movw	r26, r24
     da4:	cb 01       	movw	r24, r22
     da6:	2b e0       	ldi	r18, 0x0B	; 11
     da8:	b5 95       	asr	r27
     daa:	a7 95       	ror	r26
     dac:	97 95       	ror	r25
     dae:	87 95       	ror	r24
     db0:	2a 95       	dec	r18
     db2:	d1 f7       	brne	.-12     	; 0xda8 <UartClass::begin(unsigned long, unsigned int)+0x7a>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:249
    #endif
  #endif

  // Make sure global interrupts are disabled during initialization
  // no reason to do this before we potentially do all that long division, right?
  uint8_t oldSREG = SREG;
     db4:	ff b6       	in	r15, 0x3f	; 63
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:250
  cli();
     db6:	f8 94       	cli
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:252
  // assign the baud_setting, a.k.a. BAUD (USART Baud Rate Register)
  (*_hwserial_module).BAUD = (uint16_t)baud_setting;
     db8:	ec 85       	ldd	r30, Y+12	; 0x0c
     dba:	fd 85       	ldd	r31, Y+13	; 0x0d
     dbc:	00 97       	sbiw	r24, 0x00	; 0
     dbe:	21 e0       	ldi	r18, 0x01	; 1
     dc0:	a2 07       	cpc	r26, r18
     dc2:	b1 05       	cpc	r27, r1
     dc4:	24 f0       	brlt	.+8      	; 0xdce <UartClass::begin(unsigned long, unsigned int)+0xa0>
     dc6:	8f ef       	ldi	r24, 0xFF	; 255
     dc8:	9f ef       	ldi	r25, 0xFF	; 255
     dca:	a0 e0       	ldi	r26, 0x00	; 0
     dcc:	b0 e0       	ldi	r27, 0x00	; 0
     dce:	80 87       	std	Z+8, r24	; 0x08
     dd0:	91 87       	std	Z+9, r25	; 0x09
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:255

  // Set USART mode of operation
  (*_hwserial_module).CTRLC = config;
     dd2:	ec 85       	ldd	r30, Y+12	; 0x0c
     dd4:	fd 85       	ldd	r31, Y+13	; 0x0d
     dd6:	d7 82       	std	Z+7, r13	; 0x07
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:258

  // Enable transmitter and receiver
  (*_hwserial_module).CTRLB = ((*_hwserial_module).CTRLB&(~USART_RXMODE_gm)) | rxmode | (USART_RXEN_bm | USART_TXEN_bm);
     dd8:	ec 85       	ldd	r30, Y+12	; 0x0c
     dda:	fd 85       	ldd	r31, Y+13	; 0x0d
     ddc:	86 81       	ldd	r24, Z+6	; 0x06
     dde:	89 7f       	andi	r24, 0xF9	; 249
     de0:	80 6c       	ori	r24, 0xC0	; 192
     de2:	8e 29       	or	r24, r14
     de4:	86 83       	std	Z+6, r24	; 0x06
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:260

  (*_hwserial_module).CTRLA |= USART_RXCIE_bm;
     de6:	ec 85       	ldd	r30, Y+12	; 0x0c
     de8:	fd 85       	ldd	r31, Y+13	; 0x0d
     dea:	85 81       	ldd	r24, Z+5	; 0x05
     dec:	80 68       	ori	r24, 0x80	; 128
     dee:	85 83       	std	Z+5, r24	; 0x05
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:265


  // Let PORTMUX point to alternative UART pins as requested
  #ifdef PORTMUX_CTRLB
    PORTMUX.CTRLB = set->mux | (PORTMUX.CTRLB & ~_hw_set[1].mux);
     df0:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <digital_pin_to_port+0x7f67ad>
     df4:	8b 89       	ldd	r24, Y+19	; 0x13
     df6:	80 95       	com	r24
     df8:	89 23       	and	r24, r25
     dfa:	98 01       	movw	r18, r16
     dfc:	22 0f       	add	r18, r18
     dfe:	33 1f       	adc	r19, r19
     e00:	02 0f       	add	r16, r18
     e02:	13 1f       	adc	r17, r19
     e04:	c0 0f       	add	r28, r16
     e06:	d1 1f       	adc	r29, r17
     e08:	98 89       	ldd	r25, Y+16	; 0x10
     e0a:	89 2b       	or	r24, r25
     e0c:	80 93 01 02 	sts	0x0201, r24	; 0x800201 <digital_pin_to_port+0x7f67ad>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:271
  #else
    PORTMUX.USARTROUTEA = set->mux | (PORTMUX.USARTROUTEA & ~_hw_set[1].mux);
  #endif

  // Set pin state for swapped UART pins
  pinMode(set->rx_pin, INPUT_PULLUP);
     e10:	62 e0       	ldi	r22, 0x02	; 2
     e12:	8e 85       	ldd	r24, Y+14	; 0x0e
     e14:	0e 94 b9 05 	call	0xb72	; 0xb72 <pinMode>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:273
  //digitalWrite(set->tx_pin, HIGH);
  pinMode(set->tx_pin, OUTPUT);
     e18:	61 e0       	ldi	r22, 0x01	; 1
     e1a:	8f 85       	ldd	r24, Y+15	; 0x0f
     e1c:	0e 94 b9 05 	call	0xb72	; 0xb72 <pinMode>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:276

  // Restore SREG content
  SREG = oldSREG;
     e20:	ff be       	out	0x3f, r15	; 63
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:277
}
     e22:	df 91       	pop	r29
     e24:	cf 91       	pop	r28
     e26:	1f 91       	pop	r17
     e28:	0f 91       	pop	r16
     e2a:	ff 90       	pop	r15
     e2c:	ef 90       	pop	r14
     e2e:	df 90       	pop	r13
     e30:	bf 90       	pop	r11
     e32:	af 90       	pop	r10
     e34:	9f 90       	pop	r9
     e36:	8f 90       	pop	r8
     e38:	08 95       	ret

00000e3a <__vector_28>:
__vector_28():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART0.cpp:48
#else
#error "Don't know what the Data Received interrupt vector is called for Serial"
#endif

#if defined(HWSERIAL0_DRE_VECTOR)
ISR(HWSERIAL0_DRE_VECTOR) {
     e3a:	1f 92       	push	r1
     e3c:	0f 92       	push	r0
     e3e:	0f b6       	in	r0, 0x3f	; 63
     e40:	0f 92       	push	r0
     e42:	11 24       	eor	r1, r1
     e44:	2f 93       	push	r18
     e46:	3f 93       	push	r19
     e48:	4f 93       	push	r20
     e4a:	5f 93       	push	r21
     e4c:	6f 93       	push	r22
     e4e:	7f 93       	push	r23
     e50:	8f 93       	push	r24
     e52:	9f 93       	push	r25
     e54:	af 93       	push	r26
     e56:	bf 93       	push	r27
     e58:	ef 93       	push	r30
     e5a:	ff 93       	push	r31
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART0.cpp:49
  Serial._tx_data_empty_irq();
     e5c:	82 e8       	ldi	r24, 0x82	; 130
     e5e:	99 e3       	ldi	r25, 0x39	; 57
     e60:	0e 94 25 02 	call	0x44a	; 0x44a <UartClass::_tx_data_empty_irq()>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART0.cpp:50
}
     e64:	ff 91       	pop	r31
     e66:	ef 91       	pop	r30
     e68:	bf 91       	pop	r27
     e6a:	af 91       	pop	r26
     e6c:	9f 91       	pop	r25
     e6e:	8f 91       	pop	r24
     e70:	7f 91       	pop	r23
     e72:	6f 91       	pop	r22
     e74:	5f 91       	pop	r21
     e76:	4f 91       	pop	r20
     e78:	3f 91       	pop	r19
     e7a:	2f 91       	pop	r18
     e7c:	0f 90       	pop	r0
     e7e:	0f be       	out	0x3f, r0	; 63
     e80:	0f 90       	pop	r0
     e82:	1f 90       	pop	r1
     e84:	18 95       	reti

00000e86 <__vector_27>:
__vector_27():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART0.cpp:40
// first place.

#if defined(HAVE_HWSERIAL0)

#if defined(HWSERIAL0_RXC_VECTOR)
ISR(HWSERIAL0_RXC_VECTOR) {
     e86:	1f 92       	push	r1
     e88:	0f 92       	push	r0
     e8a:	0f b6       	in	r0, 0x3f	; 63
     e8c:	0f 92       	push	r0
     e8e:	11 24       	eor	r1, r1
     e90:	2f 93       	push	r18
     e92:	8f 93       	push	r24
     e94:	9f 93       	push	r25
     e96:	ef 93       	push	r30
     e98:	ff 93       	push	r31
_rx_complete_irq():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART_private.h:59

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void UartClass::_rx_complete_irq(void) {
  //if (bit_is_clear(*_rxdatah, USART_PERR_bp)) {
  if (!(((*_hwserial_module).RXDATAH) & USART_PERR_bm)) {
     e9a:	e0 91 8e 39 	lds	r30, 0x398E	; 0x80398e <Serial+0xc>
     e9e:	f0 91 8f 39 	lds	r31, 0x398F	; 0x80398f <Serial+0xd>
     ea2:	81 81       	ldd	r24, Z+1	; 0x01
     ea4:	81 fd       	sbrc	r24, 1
     ea6:	1b c0       	rjmp	.+54     	; 0xede <__vector_27+0x58>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART_private.h:62
    // No Parity error, read byte and store it in the buffer if there is
    // room
    unsigned char c = (*_hwserial_module).RXDATAL;
     ea8:	90 81       	ld	r25, Z
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART_private.h:63
    rx_buffer_index_t i = (unsigned int)(_rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;
     eaa:	80 91 98 39 	lds	r24, 0x3998	; 0x803998 <Serial+0x16>
     eae:	8f 5f       	subi	r24, 0xFF	; 255
     eb0:	8f 73       	andi	r24, 0x3F	; 63
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART_private.h:69

    // if we should be storing the received character into the location
    // just before the tail (meaning that the head would advance to the
    // current location of the tail), we're about to overflow the buffer
    // and so we don't write the character or advance the head.
    if (i != _rx_buffer_tail) {
     eb2:	20 91 99 39 	lds	r18, 0x3999	; 0x803999 <Serial+0x17>
     eb6:	82 17       	cp	r24, r18
     eb8:	41 f0       	breq	.+16     	; 0xeca <__vector_27+0x44>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART_private.h:70
      _rx_buffer[_rx_buffer_head] = c;
     eba:	e0 91 98 39 	lds	r30, 0x3998	; 0x803998 <Serial+0x16>
     ebe:	f0 e0       	ldi	r31, 0x00	; 0
     ec0:	ee 57       	subi	r30, 0x7E	; 126
     ec2:	f6 4c       	sbci	r31, 0xC6	; 198
     ec4:	93 8f       	std	Z+27, r25	; 0x1b
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART_private.h:71
      _rx_buffer_head = i;
     ec6:	80 93 98 39 	sts	0x3998, r24	; 0x803998 <Serial+0x16>
__vector_27():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART0.cpp:42
  Serial._rx_complete_irq();
}
     eca:	ff 91       	pop	r31
     ecc:	ef 91       	pop	r30
     ece:	9f 91       	pop	r25
     ed0:	8f 91       	pop	r24
     ed2:	2f 91       	pop	r18
     ed4:	0f 90       	pop	r0
     ed6:	0f be       	out	0x3f, r0	; 63
     ed8:	0f 90       	pop	r0
     eda:	1f 90       	pop	r1
     edc:	18 95       	reti
_rx_complete_irq():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART_private.h:75
    }
  } else {
    // Parity error, read byte but discard it
    (*_hwserial_module).RXDATAL;
     ede:	80 81       	ld	r24, Z
     ee0:	f4 cf       	rjmp	.-24     	; 0xeca <__vector_27+0x44>

00000ee2 <__vector_15>:
__vector_15():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:130
#elif defined(MILLIS_USE_TIMERB1)
  ISR(TCB1_INT_vect)
#else
  #error "No millis timer selected, but not disabled - cannot determine millis vector"
#endif
{
     ee2:	1f 92       	push	r1
     ee4:	0f 92       	push	r0
     ee6:	0f b6       	in	r0, 0x3f	; 63
     ee8:	0f 92       	push	r0
     eea:	11 24       	eor	r1, r1
     eec:	2f 93       	push	r18
     eee:	3f 93       	push	r19
     ef0:	4f 93       	push	r20
     ef2:	5f 93       	push	r21
     ef4:	6f 93       	push	r22
     ef6:	8f 93       	push	r24
     ef8:	9f 93       	push	r25
     efa:	af 93       	push	r26
     efc:	bf 93       	push	r27
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:142
  #else
  timer_millis += 2;
  #endif
  #else
  #if !defined(MILLIS_USE_TIMERRTC) //TCA0 or TCD0
  uint32_t m = timer_millis;
     efe:	80 91 78 38 	lds	r24, 0x3878	; 0x803878 <timer_millis>
     f02:	90 91 79 38 	lds	r25, 0x3879	; 0x803879 <timer_millis+0x1>
     f06:	a0 91 7a 38 	lds	r26, 0x387A	; 0x80387a <timer_millis+0x2>
     f0a:	b0 91 7b 38 	lds	r27, 0x387B	; 0x80387b <timer_millis+0x3>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:143
  uint16_t f = timer_fract;
     f0e:	40 91 0c 38 	lds	r20, 0x380C	; 0x80380c <timer_fract>
     f12:	50 91 0d 38 	lds	r21, 0x380D	; 0x80380d <timer_fract+0x1>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:145
  m += MILLIS_INC;
  f += FRACT_INC;
     f16:	9a 01       	movw	r18, r20
     f18:	20 5d       	subi	r18, 0xD0	; 208
     f1a:	3c 4f       	sbci	r19, 0xFC	; 252
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:146
  if (f >= FRACT_MAX) {
     f1c:	28 3e       	cpi	r18, 0xE8	; 232
     f1e:	63 e0       	ldi	r22, 0x03	; 3
     f20:	36 07       	cpc	r19, r22
     f22:	28 f0       	brcs	.+10     	; 0xf2e <__vector_15+0x4c>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:148

    f -= FRACT_MAX;
     f24:	28 5e       	subi	r18, 0xE8	; 232
     f26:	33 40       	sbci	r19, 0x03	; 3
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:149
    m += 1;
     f28:	01 96       	adiw	r24, 0x01	; 1
     f2a:	a1 1d       	adc	r26, r1
     f2c:	b1 1d       	adc	r27, r1
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:151
  }
  timer_fract = f;
     f2e:	20 93 0c 38 	sts	0x380C, r18	; 0x80380c <timer_fract>
     f32:	30 93 0d 38 	sts	0x380D, r19	; 0x80380d <timer_fract+0x1>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:152
  timer_millis = m;
     f36:	80 93 78 38 	sts	0x3878, r24	; 0x803878 <timer_millis>
     f3a:	90 93 79 38 	sts	0x3879, r25	; 0x803879 <timer_millis+0x1>
     f3e:	a0 93 7a 38 	sts	0x387A, r26	; 0x80387a <timer_millis+0x2>
     f42:	b0 93 7b 38 	sts	0x387B, r27	; 0x80387b <timer_millis+0x3>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:155
  #endif
  //if RTC is used as timer, we only increment the overflow count
  timer_overflow_count++;
     f46:	80 91 0e 38 	lds	r24, 0x380E	; 0x80380e <timer_overflow_count>
     f4a:	90 91 0f 38 	lds	r25, 0x380F	; 0x80380f <timer_overflow_count+0x1>
     f4e:	a0 91 10 38 	lds	r26, 0x3810	; 0x803810 <timer_overflow_count+0x2>
     f52:	b0 91 11 38 	lds	r27, 0x3811	; 0x803811 <timer_overflow_count+0x3>
     f56:	01 96       	adiw	r24, 0x01	; 1
     f58:	a1 1d       	adc	r26, r1
     f5a:	b1 1d       	adc	r27, r1
     f5c:	80 93 0e 38 	sts	0x380E, r24	; 0x80380e <timer_overflow_count>
     f60:	90 93 0f 38 	sts	0x380F, r25	; 0x80380f <timer_overflow_count+0x1>
     f64:	a0 93 10 38 	sts	0x3810, r26	; 0x803810 <timer_overflow_count+0x2>
     f68:	b0 93 11 38 	sts	0x3811, r27	; 0x803811 <timer_overflow_count+0x3>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:161
  #endif
  /* Clear flag */
  #if defined(MILLIS_USE_TIMERA0)
  TCA0.SPLIT.INTFLAGS = TCA_SPLIT_HUNF_bm;
  #elif defined(MILLIS_USE_TIMERD0)
  TCD0.INTFLAGS = TCD_OVF_bm;
     f6c:	81 e0       	ldi	r24, 0x01	; 1
     f6e:	80 93 8d 0a 	sts	0x0A8D, r24	; 0x800a8d <digital_pin_to_port+0x7f7039>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:167
  #elif defined(MILLIS_USE_TIMERRTC)
  RTC.INTFLAGS = RTC_OVF_bm;
  #else //timerb
  _timer->INTFLAGS = TCB_CAPT_bm;
  #endif
}
     f72:	bf 91       	pop	r27
     f74:	af 91       	pop	r26
     f76:	9f 91       	pop	r25
     f78:	8f 91       	pop	r24
     f7a:	6f 91       	pop	r22
     f7c:	5f 91       	pop	r21
     f7e:	4f 91       	pop	r20
     f80:	3f 91       	pop	r19
     f82:	2f 91       	pop	r18
     f84:	0f 90       	pop	r0
     f86:	0f be       	out	0x3f, r0	; 63
     f88:	0f 90       	pop	r0
     f8a:	1f 90       	pop	r1
     f8c:	18 95       	reti

00000f8e <__vector_24>:
__vector_24():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:765

ISR(TWI0_TWIM_vect) {
  TWI_MasterInterruptHandler();
}

ISR(TWI0_TWIS_vect) {
     f8e:	1f 92       	push	r1
     f90:	0f 92       	push	r0
     f92:	0f b6       	in	r0, 0x3f	; 63
     f94:	0f 92       	push	r0
     f96:	11 24       	eor	r1, r1
     f98:	2f 93       	push	r18
     f9a:	3f 93       	push	r19
     f9c:	4f 93       	push	r20
     f9e:	5f 93       	push	r21
     fa0:	6f 93       	push	r22
     fa2:	7f 93       	push	r23
     fa4:	8f 93       	push	r24
     fa6:	9f 93       	push	r25
     fa8:	af 93       	push	r26
     faa:	bf 93       	push	r27
     fac:	cf 93       	push	r28
     fae:	ef 93       	push	r30
     fb0:	ff 93       	push	r31
TWI_SlaveInterruptHandler():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:528

    Check current status and calls the appropriate handler.

*/
void TWI_SlaveInterruptHandler() {
  uint8_t currentStatus = TWI0.SSTATUS;
     fb2:	c0 91 1b 08 	lds	r28, 0x081B	; 0x80081b <digital_pin_to_port+0x7f6dc7>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:531

  /* If bus error */
  if (currentStatus & TWI_BUSERR_bm) {
     fb6:	c2 ff       	sbrs	r28, 2
     fb8:	0a c0       	rjmp	.+20     	; 0xfce <__vector_24+0x40>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:532
    slave_bytesRead = 0;
     fba:	10 92 20 38 	sts	0x3820, r1	; 0x803820 <slave_bytesRead>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:533
    slave_bytesWritten = 0;
     fbe:	10 92 1f 38 	sts	0x381F, r1	; 0x80381f <slave_bytesWritten>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:534
    slave_bytesToWrite = 0;
     fc2:	10 92 0b 38 	sts	0x380B, r1	; 0x80380b <slave_bytesToWrite>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:535
    TWI_SlaveTransactionFinished(TWIS_RESULT_BUS_ERROR);
     fc6:	84 e0       	ldi	r24, 0x04	; 4
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:589
    }
  }

  /* If unexpected state */
  else {
    TWI_SlaveTransactionFinished(TWIS_RESULT_FAIL);
     fc8:	0e 94 09 04 	call	0x812	; 0x812 <TWI_SlaveTransactionFinished>
     fcc:	14 c0       	rjmp	.+40     	; 0xff6 <__vector_24+0x68>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:539
    slave_bytesToWrite = 0;
    TWI_SlaveTransactionFinished(TWIS_RESULT_BUS_ERROR);
  }

  /* If Address or Stop */
  else if (currentStatus & TWI_APIF_bm) {
     fce:	c6 ff       	sbrs	r28, 6
     fd0:	2f c0       	rjmp	.+94     	; 0x1030 <__vector_24+0xa2>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:544

    /* Call user onReceive function if end of Master Write/Slave Read.
       This should be hit when there is a STOP or REPSTART
    */
    if (slave_callUserReceive == 1) {
     fd2:	80 91 1b 38 	lds	r24, 0x381B	; 0x80381b <slave_callUserReceive>
     fd6:	81 30       	cpi	r24, 0x01	; 1
     fd8:	51 f4       	brne	.+20     	; 0xfee <__vector_24+0x60>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:545
      TWI_onSlaveReceive(slave_bytesRead);
     fda:	80 91 20 38 	lds	r24, 0x3820	; 0x803820 <slave_bytesRead>
     fde:	e0 91 15 38 	lds	r30, 0x3815	; 0x803815 <TWI_onSlaveReceive>
     fe2:	f0 91 16 38 	lds	r31, 0x3816	; 0x803816 <TWI_onSlaveReceive+0x1>
     fe6:	90 e0       	ldi	r25, 0x00	; 0
     fe8:	09 95       	icall
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:546
      slave_callUserReceive = 0;
     fea:	10 92 1b 38 	sts	0x381B, r1	; 0x80381b <slave_callUserReceive>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:550
    }

    /* If address match */
    if (currentStatus & TWI_AP_bm) {
     fee:	c0 ff       	sbrs	r28, 0
     ff0:	14 c0       	rjmp	.+40     	; 0x101a <__vector_24+0x8c>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:551
      TWI_SlaveAddressMatchHandler();
     ff2:	0e 94 16 04 	call	0x82c	; 0x82c <TWI_SlaveAddressMatchHandler>
__vector_24():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:767
  TWI_MasterInterruptHandler();
}

ISR(TWI0_TWIS_vect) {
  TWI_SlaveInterruptHandler();
}
     ff6:	ff 91       	pop	r31
     ff8:	ef 91       	pop	r30
     ffa:	cf 91       	pop	r28
     ffc:	bf 91       	pop	r27
     ffe:	af 91       	pop	r26
    1000:	9f 91       	pop	r25
    1002:	8f 91       	pop	r24
    1004:	7f 91       	pop	r23
    1006:	6f 91       	pop	r22
    1008:	5f 91       	pop	r21
    100a:	4f 91       	pop	r20
    100c:	3f 91       	pop	r19
    100e:	2f 91       	pop	r18
    1010:	0f 90       	pop	r0
    1012:	0f be       	out	0x3f, r0	; 63
    1014:	0f 90       	pop	r0
    1016:	1f 90       	pop	r1
    1018:	18 95       	reti
TWI_SlaveStopHandler():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:629

*/
void TWI_SlaveStopHandler() {

  /* Clear APIF, don't ACK or NACK */
  TWI0.SSTATUS = TWI_APIF_bm;
    101a:	80 e4       	ldi	r24, 0x40	; 64
    101c:	80 93 1b 08 	sts	0x081B, r24	; 0x80081b <digital_pin_to_port+0x7f6dc7>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:631

  TWI_SlaveTransactionFinished(TWIS_RESULT_OK);
    1020:	81 e0       	ldi	r24, 0x01	; 1
    1022:	0e 94 09 04 	call	0x812	; 0x812 <TWI_SlaveTransactionFinished>
TWI_SlaveInterruptHandler():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:562

      /* If CLKHOLD is high, we have missed an address match
        from a fast start after stop.
        Because the flag is shared we need to handle this here.
      */
      if (TWI0.SSTATUS & TWI_CLKHOLD_bm) {
    1026:	80 91 1b 08 	lds	r24, 0x081B	; 0x80081b <digital_pin_to_port+0x7f6dc7>
    102a:	85 ff       	sbrs	r24, 5
    102c:	e4 cf       	rjmp	.-56     	; 0xff6 <__vector_24+0x68>
    102e:	e1 cf       	rjmp	.-62     	; 0xff2 <__vector_24+0x64>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:571
      }
    }
  }

  /* If Data Interrupt */
  else if (currentStatus & TWI_DIF_bm) {
    1030:	c7 ff       	sbrs	r28, 7
    1032:	5c c0       	rjmp	.+184    	; 0x10ec <__vector_24+0x15e>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:574

    /* If collision flag is raised, slave transmit unsuccessful */
    if (currentStatus & TWI_COLL_bm) {
    1034:	c3 ff       	sbrs	r28, 3
    1036:	08 c0       	rjmp	.+16     	; 0x1048 <__vector_24+0xba>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:575
      slave_bytesRead = 0;
    1038:	10 92 20 38 	sts	0x3820, r1	; 0x803820 <slave_bytesRead>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:576
      slave_bytesWritten = 0;
    103c:	10 92 1f 38 	sts	0x381F, r1	; 0x80381f <slave_bytesWritten>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:577
      slave_bytesToWrite = 0;
    1040:	10 92 0b 38 	sts	0x380B, r1	; 0x80380b <slave_bytesToWrite>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:578
      TWI_SlaveTransactionFinished(TWIS_RESULT_TRANSMIT_COLLISION);
    1044:	83 e0       	ldi	r24, 0x03	; 3
    1046:	c0 cf       	rjmp	.-128    	; 0xfc8 <__vector_24+0x3a>
TWI_SlaveDataHandler():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:644

*/
void TWI_SlaveDataHandler() {

  /* Enable stop interrupt */
  TWI0.SCTRLA |= (TWI_APIEN_bm | TWI_PIEN_bm);
    1048:	80 91 19 08 	lds	r24, 0x0819	; 0x800819 <digital_pin_to_port+0x7f6dc5>
    104c:	80 66       	ori	r24, 0x60	; 96
    104e:	80 93 19 08 	sts	0x0819, r24	; 0x800819 <digital_pin_to_port+0x7f6dc5>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:647

  /* If Master Read/Slave Write */
  if (TWI0.SSTATUS & TWI_DIR_bm) {
    1052:	80 91 1b 08 	lds	r24, 0x081B	; 0x80081b <digital_pin_to_port+0x7f6dc7>
    1056:	81 ff       	sbrs	r24, 1
    1058:	2c c0       	rjmp	.+88     	; 0x10b2 <__vector_24+0x124>
TWI_SlaveWriteHandler():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:668

*/
void TWI_SlaveWriteHandler() {

  /* If NACK, slave write transaction finished */
  if ((slave_bytesWritten > 0) && (TWI0.SSTATUS & TWI_RXACK_bm)) {
    105a:	80 91 1f 38 	lds	r24, 0x381F	; 0x80381f <slave_bytesWritten>
    105e:	88 23       	and	r24, r24
    1060:	49 f0       	breq	.+18     	; 0x1074 <__vector_24+0xe6>
    1062:	80 91 1b 08 	lds	r24, 0x081B	; 0x80081b <digital_pin_to_port+0x7f6dc7>
    1066:	84 ff       	sbrs	r24, 4
    1068:	05 c0       	rjmp	.+10     	; 0x1074 <__vector_24+0xe6>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:670

    TWI0.SCTRLB = TWI_SCMD_COMPTRANS_gc;
    106a:	82 e0       	ldi	r24, 0x02	; 2
    106c:	80 93 1a 08 	sts	0x081A, r24	; 0x80081a <digital_pin_to_port+0x7f6dc6>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:671
    TWI_SlaveTransactionFinished(TWIS_RESULT_OK);
    1070:	81 e0       	ldi	r24, 0x01	; 1
    1072:	aa cf       	rjmp	.-172    	; 0xfc8 <__vector_24+0x3a>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:677
  }

  /* If ACK, master expects more data */
  else {

    if (slave_bytesWritten < slave_bytesToWrite) {
    1074:	90 91 1f 38 	lds	r25, 0x381F	; 0x80381f <slave_bytesWritten>
    1078:	80 91 0b 38 	lds	r24, 0x380B	; 0x80380b <slave_bytesToWrite>
    107c:	98 17       	cp	r25, r24
    107e:	a8 f4       	brcc	.+42     	; 0x10aa <__vector_24+0x11c>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:678
      uint8_t data = slave_writeData[slave_bytesWritten];
    1080:	e0 91 1f 38 	lds	r30, 0x381F	; 0x80381f <slave_bytesWritten>
    1084:	80 91 17 38 	lds	r24, 0x3817	; 0x803817 <slave_writeData>
    1088:	90 91 18 38 	lds	r25, 0x3818	; 0x803818 <slave_writeData+0x1>
    108c:	e8 0f       	add	r30, r24
    108e:	f9 2f       	mov	r31, r25
    1090:	f1 1d       	adc	r31, r1
    1092:	80 81       	ld	r24, Z
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:679
      TWI0.SDATA = data;
    1094:	80 93 1d 08 	sts	0x081D, r24	; 0x80081d <digital_pin_to_port+0x7f6dc9>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:680
      slave_bytesWritten++;
    1098:	80 91 1f 38 	lds	r24, 0x381F	; 0x80381f <slave_bytesWritten>
    109c:	8f 5f       	subi	r24, 0xFF	; 255
    109e:	80 93 1f 38 	sts	0x381F, r24	; 0x80381f <slave_bytesWritten>
TWI_SlaveReadHandler():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:714
    uint8_t data = TWI0.SDATA;
    slave_readData[slave_bytesRead] = data;
    slave_bytesRead++;

    /* Send ACK and wait for data interrupt */
    TWI0.SCTRLB = TWI_SCMD_RESPONSE_gc;
    10a2:	83 e0       	ldi	r24, 0x03	; 3
    10a4:	80 93 1a 08 	sts	0x081A, r24	; 0x80081a <digital_pin_to_port+0x7f6dc6>
    10a8:	a6 cf       	rjmp	.-180    	; 0xff6 <__vector_24+0x68>
TWI_SlaveWriteHandler():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:689

    }

    /* If buffer overflow */
    else {
      TWI0.SCTRLB = TWI_SCMD_COMPTRANS_gc;
    10aa:	82 e0       	ldi	r24, 0x02	; 2
    10ac:	80 93 1a 08 	sts	0x081A, r24	; 0x80081a <digital_pin_to_port+0x7f6dc6>
    10b0:	8b cf       	rjmp	.-234    	; 0xfc8 <__vector_24+0x3a>
TWI_SlaveReadHandler():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:706

*/
void TWI_SlaveReadHandler() {

  /* If free space in buffer */
  if (slave_bytesRead < slave_bytesToRead) {
    10b2:	90 91 20 38 	lds	r25, 0x3820	; 0x803820 <slave_bytesRead>
    10b6:	80 91 12 38 	lds	r24, 0x3812	; 0x803812 <slave_bytesToRead>
    10ba:	98 17       	cp	r25, r24
    10bc:	90 f4       	brcc	.+36     	; 0x10e2 <__vector_24+0x154>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:709

    /* Fetch data */
    uint8_t data = TWI0.SDATA;
    10be:	80 91 1d 08 	lds	r24, 0x081D	; 0x80081d <digital_pin_to_port+0x7f6dc9>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:710
    slave_readData[slave_bytesRead] = data;
    10c2:	e0 91 20 38 	lds	r30, 0x3820	; 0x803820 <slave_bytesRead>
    10c6:	20 91 13 38 	lds	r18, 0x3813	; 0x803813 <slave_readData>
    10ca:	30 91 14 38 	lds	r19, 0x3814	; 0x803814 <slave_readData+0x1>
    10ce:	e2 0f       	add	r30, r18
    10d0:	f3 2f       	mov	r31, r19
    10d2:	f1 1d       	adc	r31, r1
    10d4:	80 83       	st	Z, r24
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:711
    slave_bytesRead++;
    10d6:	80 91 20 38 	lds	r24, 0x3820	; 0x803820 <slave_bytesRead>
    10da:	8f 5f       	subi	r24, 0xFF	; 255
    10dc:	80 93 20 38 	sts	0x3820, r24	; 0x803820 <slave_bytesRead>
    10e0:	e0 cf       	rjmp	.-64     	; 0x10a2 <__vector_24+0x114>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:719
    TWI0.SCTRLB = TWI_SCMD_RESPONSE_gc;
  }
  /* If buffer overflow, send NACK and wait for next START.
    Set result buffer overflow */
  else {
    TWI0.SCTRLB = TWI_ACKACT_bm | TWI_SCMD_COMPTRANS_gc;
    10e2:	86 e0       	ldi	r24, 0x06	; 6
    10e4:	80 93 1a 08 	sts	0x081A, r24	; 0x80081a <digital_pin_to_port+0x7f6dc6>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:720
    TWI_SlaveTransactionFinished(TWIS_RESULT_BUFFER_OVERFLOW);
    10e8:	82 e0       	ldi	r24, 0x02	; 2
    10ea:	6e cf       	rjmp	.-292    	; 0xfc8 <__vector_24+0x3a>
TWI_SlaveInterruptHandler():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:589
    }
  }

  /* If unexpected state */
  else {
    TWI_SlaveTransactionFinished(TWIS_RESULT_FAIL);
    10ec:	85 e0       	ldi	r24, 0x05	; 5
    10ee:	6c cf       	rjmp	.-296    	; 0xfc8 <__vector_24+0x3a>

000010f0 <__vector_25>:
__vector_25():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:761
  twi_mode = TWI_MODE_SLAVE;
  slave_result = result;
  slave_trans_status = TWIM_STATUS_READY;
}

ISR(TWI0_TWIM_vect) {
    10f0:	1f 92       	push	r1
    10f2:	0f 92       	push	r0
    10f4:	0f b6       	in	r0, 0x3f	; 63
    10f6:	0f 92       	push	r0
    10f8:	11 24       	eor	r1, r1
    10fa:	2f 93       	push	r18
    10fc:	8f 93       	push	r24
    10fe:	9f 93       	push	r25
    1100:	ef 93       	push	r30
    1102:	ff 93       	push	r31
TWI_MasterInterruptHandler():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:360

    Check current status and calls the appropriate handler.

*/
void TWI_MasterInterruptHandler() {
  uint8_t currentStatus = TWI0.MSTATUS;
    1104:	80 91 15 08 	lds	r24, 0x0815	; 0x800815 <digital_pin_to_port+0x7f6dc1>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:363

  /* If arbitration lost or bus error. */
  if ((currentStatus & TWI_ARBLOST_bm) ||
    1108:	98 2f       	mov	r25, r24
    110a:	9c 70       	andi	r25, 0x0C	; 12
    110c:	c1 f0       	breq	.+48     	; 0x113e <__vector_25+0x4e>
TWI_MasterArbitrationLostBusErrorHandler():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:391

    Handles TWI responses to lost arbitration and bus error.

*/
void TWI_MasterArbitrationLostBusErrorHandler() {
  uint8_t currentStatus = TWI0.MSTATUS;
    110e:	80 91 15 08 	lds	r24, 0x0815	; 0x800815 <digital_pin_to_port+0x7f6dc1>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:395

  /* If bus error. */
  if (currentStatus & TWI_BUSERR_bm) {
    master_result = TWIM_RESULT_BUS_ERROR;
    1112:	94 e0       	ldi	r25, 0x04	; 4
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:394
*/
void TWI_MasterArbitrationLostBusErrorHandler() {
  uint8_t currentStatus = TWI0.MSTATUS;

  /* If bus error. */
  if (currentStatus & TWI_BUSERR_bm) {
    1114:	82 ff       	sbrs	r24, 2
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:399
    master_result = TWIM_RESULT_BUS_ERROR;
  }
  /* If arbitration lost. */
  else {
    master_result = TWIM_RESULT_ARBITRATION_LOST;
    1116:	93 e0       	ldi	r25, 0x03	; 3
    1118:	90 93 0a 38 	sts	0x380A, r25	; 0x80380a <master_result>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:403
  }

  /* Clear all flags, abort operation */
  TWI0.MSTATUS = currentStatus;
    111c:	80 93 15 08 	sts	0x0815, r24	; 0x800815 <digital_pin_to_port+0x7f6dc1>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:406

  /* Wait for a new operation */
  twi_mode = TWI_MODE_MASTER;
    1120:	81 e0       	ldi	r24, 0x01	; 1
    1122:	80 93 21 38 	sts	0x3821, r24	; 0x803821 <twi_mode>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:407
  master_trans_status = TWIM_STATUS_READY;
    1126:	10 92 09 38 	sts	0x3809, r1	; 0x803809 <master_trans_status>
__vector_25():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:763
  slave_trans_status = TWIM_STATUS_READY;
}

ISR(TWI0_TWIM_vect) {
  TWI_MasterInterruptHandler();
}
    112a:	ff 91       	pop	r31
    112c:	ef 91       	pop	r30
    112e:	9f 91       	pop	r25
    1130:	8f 91       	pop	r24
    1132:	2f 91       	pop	r18
    1134:	0f 90       	pop	r0
    1136:	0f be       	out	0x3f, r0	; 63
    1138:	0f 90       	pop	r0
    113a:	1f 90       	pop	r1
    113c:	18 95       	reti
TWI_MasterInterruptHandler():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:370

    TWI_MasterArbitrationLostBusErrorHandler();
  }

  /* If master write interrupt. */
  else if (currentStatus & TWI_WIF_bm) {
    113e:	86 ff       	sbrs	r24, 6
    1140:	46 c0       	rjmp	.+140    	; 0x11ce <__vector_25+0xde>
TWI_MasterWriteHandler():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:418
    Handles TWI transactions (master write) and responses to (N)ACK.

*/
void TWI_MasterWriteHandler() {
  /* Local variables used in if tests to avoid compiler warning. */
  uint8_t bytesToWrite  = master_bytesToWrite;
    1142:	20 91 05 38 	lds	r18, 0x3805	; 0x803805 <master_bytesToWrite>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:419
  uint8_t bytesToRead   = master_bytesToRead;
    1146:	90 91 07 38 	lds	r25, 0x3807	; 0x803807 <master_bytesToRead>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:422

  /* If NOT acknowledged (NACK) by slave cancel the transaction. */
  if (TWI0.MSTATUS & TWI_RXACK_bm) {
    114a:	80 91 15 08 	lds	r24, 0x0815	; 0x800815 <digital_pin_to_port+0x7f6dc1>
    114e:	84 ff       	sbrs	r24, 4
    1150:	10 c0       	rjmp	.+32     	; 0x1172 <__vector_25+0x82>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:423
    if (master_sendStop) {
    1152:	80 91 06 38 	lds	r24, 0x3806	; 0x803806 <master_sendStop>
    1156:	88 23       	and	r24, r24
    1158:	51 f0       	breq	.+20     	; 0x116e <__vector_25+0x7e>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:424
      TWI0.MCTRLB = TWI_MCMD_STOP_gc;
    115a:	83 e0       	ldi	r24, 0x03	; 3
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:426
    } else {
      TWI0.MCTRLB = TWI_MCMD_REPSTART_gc;
    115c:	80 93 14 08 	sts	0x0814, r24	; 0x800814 <digital_pin_to_port+0x7f6dc0>
TWI_MasterTransactionFinished():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:516
    Prepares module for new transaction.

    \param result  The result of the operation.
*/
void TWI_MasterTransactionFinished(uint8_t result) {
  master_result = result;
    1160:	85 e0       	ldi	r24, 0x05	; 5
    1162:	80 93 0a 38 	sts	0x380A, r24	; 0x80380a <master_result>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:517
  master_trans_status = TWIM_STATUS_READY;
    1166:	10 92 09 38 	sts	0x3809, r1	; 0x803809 <master_trans_status>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:518
  twi_mode = TWI_MODE_MASTER;
    116a:	81 e0       	ldi	r24, 0x01	; 1
    116c:	2b c0       	rjmp	.+86     	; 0x11c4 <__vector_25+0xd4>
TWI_MasterWriteHandler():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:426
  /* If NOT acknowledged (NACK) by slave cancel the transaction. */
  if (TWI0.MSTATUS & TWI_RXACK_bm) {
    if (master_sendStop) {
      TWI0.MCTRLB = TWI_MCMD_STOP_gc;
    } else {
      TWI0.MCTRLB = TWI_MCMD_REPSTART_gc;
    116e:	81 e0       	ldi	r24, 0x01	; 1
    1170:	f5 cf       	rjmp	.-22     	; 0x115c <__vector_25+0x6c>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:433
    }
    TWI_MasterTransactionFinished(TWIM_RESULT_NACK_RECEIVED);
  }

  /* If more bytes to write, send data. */
  else if (master_bytesWritten < bytesToWrite) {
    1172:	80 91 04 38 	lds	r24, 0x3804	; 0x803804 <master_bytesWritten>
    1176:	82 17       	cp	r24, r18
    1178:	60 f4       	brcc	.+24     	; 0x1192 <__vector_25+0xa2>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:434
    uint8_t data = master_writeData[master_bytesWritten];
    117a:	e0 91 04 38 	lds	r30, 0x3804	; 0x803804 <master_bytesWritten>
    117e:	f0 e0       	ldi	r31, 0x00	; 0
    1180:	80 81       	ld	r24, Z
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:435
    TWI0.MDATA = data;
    1182:	80 93 18 08 	sts	0x0818, r24	; 0x800818 <digital_pin_to_port+0x7f6dc4>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:436
    master_bytesWritten++;
    1186:	80 91 04 38 	lds	r24, 0x3804	; 0x803804 <master_bytesWritten>
    118a:	8f 5f       	subi	r24, 0xFF	; 255
    118c:	80 93 04 38 	sts	0x3804, r24	; 0x803804 <master_bytesWritten>
    1190:	cc cf       	rjmp	.-104    	; 0x112a <__vector_25+0x3a>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:442
  }

  /* If bytes to read, send START condition + Address +
     'R/_W = 1'
  */
  else if (master_bytesRead < bytesToRead) {
    1192:	80 91 08 38 	lds	r24, 0x3808	; 0x803808 <master_bytesRead>
    1196:	89 17       	cp	r24, r25
    1198:	48 f4       	brcc	.+18     	; 0x11ac <__vector_25+0xbc>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:443
    twi_mode = TWI_MODE_MASTER_RECEIVE;
    119a:	84 e0       	ldi	r24, 0x04	; 4
    119c:	80 93 21 38 	sts	0x3821, r24	; 0x803821 <twi_mode>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:444
    uint8_t readAddress = ADD_READ_BIT(master_slaveAddress);
    11a0:	80 91 03 38 	lds	r24, 0x3803	; 0x803803 <master_slaveAddress>
    11a4:	81 60       	ori	r24, 0x01	; 1
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:445
    TWI0.MADDR = readAddress;
    11a6:	80 93 17 08 	sts	0x0817, r24	; 0x800817 <digital_pin_to_port+0x7f6dc3>
    11aa:	bf cf       	rjmp	.-130    	; 0x112a <__vector_25+0x3a>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:450
  }

  /* If transaction finished, send ACK/STOP condition if instructed and set RESULT OK. */
  else {
    if (master_sendStop) {
    11ac:	80 91 06 38 	lds	r24, 0x3806	; 0x803806 <master_sendStop>
    11b0:	88 23       	and	r24, r24
    11b2:	59 f0       	breq	.+22     	; 0x11ca <__vector_25+0xda>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:451
      TWI0.MCTRLB = TWI_MCMD_STOP_gc;
    11b4:	83 e0       	ldi	r24, 0x03	; 3
TWI_MasterReadHandler():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:501
  /* If transaction finished, issue NACK and STOP condition if instructed. */
  else {
    if (master_sendStop) {
      TWI0.MCTRLB = TWI_ACKACT_bm | TWI_MCMD_STOP_gc;
    } else {
      TWI0.MCTRLB = TWI_ACKACT_bm | TWI_MCMD_REPSTART_gc;
    11b6:	80 93 14 08 	sts	0x0814, r24	; 0x800814 <digital_pin_to_port+0x7f6dc0>
TWI_MasterTransactionFinished():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:516
    Prepares module for new transaction.

    \param result  The result of the operation.
*/
void TWI_MasterTransactionFinished(uint8_t result) {
  master_result = result;
    11ba:	81 e0       	ldi	r24, 0x01	; 1
    11bc:	80 93 0a 38 	sts	0x380A, r24	; 0x80380a <master_result>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:517
  master_trans_status = TWIM_STATUS_READY;
    11c0:	10 92 09 38 	sts	0x3809, r1	; 0x803809 <master_trans_status>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:518
  twi_mode = TWI_MODE_MASTER;
    11c4:	80 93 21 38 	sts	0x3821, r24	; 0x803821 <twi_mode>
    11c8:	b0 cf       	rjmp	.-160    	; 0x112a <__vector_25+0x3a>
TWI_MasterWriteHandler():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:453
  /* If transaction finished, send ACK/STOP condition if instructed and set RESULT OK. */
  else {
    if (master_sendStop) {
      TWI0.MCTRLB = TWI_MCMD_STOP_gc;
    } else {
      TWI0.MCTRLB = TWI_MCMD_REPSTART_gc;
    11ca:	81 e0       	ldi	r24, 0x01	; 1
    11cc:	f4 cf       	rjmp	.-24     	; 0x11b6 <__vector_25+0xc6>
TWI_MasterInterruptHandler():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:375
  else if (currentStatus & TWI_WIF_bm) {
    TWI_MasterWriteHandler();
  }

  /* If master read interrupt. */
  else if (currentStatus & TWI_RIF_bm) {
    11ce:	87 ff       	sbrs	r24, 7
    11d0:	37 c0       	rjmp	.+110    	; 0x1240 <__vector_25+0x150>
TWI_MasterReadHandler():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:469

    \param twi The TWI_Master_t struct instance.
*/
void TWI_MasterReadHandler() {
  /* Fetch data if bytes to be read. */
  if (master_bytesRead < master_bytesToRead) {
    11d2:	90 91 08 38 	lds	r25, 0x3808	; 0x803808 <master_bytesRead>
    11d6:	80 91 07 38 	lds	r24, 0x3807	; 0x803807 <master_bytesToRead>
    11da:	98 17       	cp	r25, r24
    11dc:	a8 f4       	brcc	.+42     	; 0x1208 <__vector_25+0x118>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:470
    uint8_t data = TWI0.MDATA;
    11de:	80 91 18 08 	lds	r24, 0x0818	; 0x800818 <digital_pin_to_port+0x7f6dc4>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:471
    master_readData[master_bytesRead] = data;
    11e2:	e0 91 08 38 	lds	r30, 0x3808	; 0x803808 <master_bytesRead>
    11e6:	f0 e0       	ldi	r31, 0x00	; 0
    11e8:	80 83       	st	Z, r24
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:472
    master_bytesRead++;
    11ea:	80 91 08 38 	lds	r24, 0x3808	; 0x803808 <master_bytesRead>
    11ee:	8f 5f       	subi	r24, 0xFF	; 255
    11f0:	80 93 08 38 	sts	0x3808, r24	; 0x803808 <master_bytesRead>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:489
    master_bytesToRead = 0;
    return;
  }

  /* Local variable used in if test to avoid compiler warning. */
  uint8_t bytesToRead = master_bytesToRead;
    11f4:	90 91 07 38 	lds	r25, 0x3807	; 0x803807 <master_bytesToRead>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:492

  /* If more bytes to read, issue ACK and start a byte read. */
  if (master_bytesRead < bytesToRead) {
    11f8:	80 91 08 38 	lds	r24, 0x3808	; 0x803808 <master_bytesRead>
    11fc:	89 17       	cp	r24, r25
    11fe:	c0 f4       	brcc	.+48     	; 0x1230 <__vector_25+0x140>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:493
    TWI0.MCTRLB = TWI_MCMD_RECVTRANS_gc;
    1200:	82 e0       	ldi	r24, 0x02	; 2
    1202:	80 93 14 08 	sts	0x0814, r24	; 0x800814 <digital_pin_to_port+0x7f6dc0>
    1206:	91 cf       	rjmp	.-222    	; 0x112a <__vector_25+0x3a>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:477
    master_bytesRead++;
  }

  /* If buffer overflow, issue NACK/STOP and BUFFER_OVERFLOW condition. */
  else {
    if (master_sendStop) {
    1208:	80 91 06 38 	lds	r24, 0x3806	; 0x803806 <master_sendStop>
    120c:	88 23       	and	r24, r24
    120e:	71 f0       	breq	.+28     	; 0x122c <__vector_25+0x13c>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:478
      TWI0.MCTRLB = TWI_ACKACT_bm | TWI_MCMD_STOP_gc;
    1210:	87 e0       	ldi	r24, 0x07	; 7
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:480
    } else {
      TWI0.MCTRLB = TWI_ACKACT_bm | TWI_MCMD_REPSTART_gc;
    1212:	80 93 14 08 	sts	0x0814, r24	; 0x800814 <digital_pin_to_port+0x7f6dc0>
TWI_MasterTransactionFinished():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:516
    Prepares module for new transaction.

    \param result  The result of the operation.
*/
void TWI_MasterTransactionFinished(uint8_t result) {
  master_result = result;
    1216:	82 e0       	ldi	r24, 0x02	; 2
    1218:	80 93 0a 38 	sts	0x380A, r24	; 0x80380a <master_result>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:517
  master_trans_status = TWIM_STATUS_READY;
    121c:	10 92 09 38 	sts	0x3809, r1	; 0x803809 <master_trans_status>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:518
  twi_mode = TWI_MODE_MASTER;
    1220:	81 e0       	ldi	r24, 0x01	; 1
    1222:	80 93 21 38 	sts	0x3821, r24	; 0x803821 <twi_mode>
TWI_MasterReadHandler():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:484
    } else {
      TWI0.MCTRLB = TWI_ACKACT_bm | TWI_MCMD_REPSTART_gc;
    }

    TWI_MasterTransactionFinished(TWIM_RESULT_BUFFER_OVERFLOW);
    master_bytesToRead = 0;
    1226:	10 92 07 38 	sts	0x3807, r1	; 0x803807 <master_bytesToRead>
    122a:	7f cf       	rjmp	.-258    	; 0x112a <__vector_25+0x3a>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:480
  /* If buffer overflow, issue NACK/STOP and BUFFER_OVERFLOW condition. */
  else {
    if (master_sendStop) {
      TWI0.MCTRLB = TWI_ACKACT_bm | TWI_MCMD_STOP_gc;
    } else {
      TWI0.MCTRLB = TWI_ACKACT_bm | TWI_MCMD_REPSTART_gc;
    122c:	85 e0       	ldi	r24, 0x05	; 5
    122e:	f1 cf       	rjmp	.-30     	; 0x1212 <__vector_25+0x122>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:498
    TWI0.MCTRLB = TWI_MCMD_RECVTRANS_gc;
  }

  /* If transaction finished, issue NACK and STOP condition if instructed. */
  else {
    if (master_sendStop) {
    1230:	80 91 06 38 	lds	r24, 0x3806	; 0x803806 <master_sendStop>
    1234:	88 23       	and	r24, r24
    1236:	11 f0       	breq	.+4      	; 0x123c <__vector_25+0x14c>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:499
      TWI0.MCTRLB = TWI_ACKACT_bm | TWI_MCMD_STOP_gc;
    1238:	87 e0       	ldi	r24, 0x07	; 7
    123a:	bd cf       	rjmp	.-134    	; 0x11b6 <__vector_25+0xc6>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:501
    } else {
      TWI0.MCTRLB = TWI_ACKACT_bm | TWI_MCMD_REPSTART_gc;
    123c:	85 e0       	ldi	r24, 0x05	; 5
    123e:	bb cf       	rjmp	.-138    	; 0x11b6 <__vector_25+0xc6>
TWI_MasterTransactionFinished():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:516
    Prepares module for new transaction.

    \param result  The result of the operation.
*/
void TWI_MasterTransactionFinished(uint8_t result) {
  master_result = result;
    1240:	86 e0       	ldi	r24, 0x06	; 6
    1242:	8f cf       	rjmp	.-226    	; 0x1162 <__vector_25+0x72>

00001244 <global constructors keyed to 65535_0_mark2_attiny1614.ino.ino.cpp.o.2890>:
_GLOBAL__I_65535_0_mark2_attiny1614.ino.ino.cpp.o.2890():
    1244:	e2 e8       	ldi	r30, 0x82	; 130
    1246:	f9 e3       	ldi	r31, 0x39	; 57
    1248:	12 82       	std	Z+2, r1	; 0x02
    124a:	13 82       	std	Z+3, r1	; 0x03
    124c:	48 ee       	ldi	r20, 0xE8	; 232
    124e:	53 e0       	ldi	r21, 0x03	; 3
    1250:	60 e0       	ldi	r22, 0x00	; 0
    1252:	70 e0       	ldi	r23, 0x00	; 0
    1254:	44 83       	std	Z+4, r20	; 0x04
    1256:	55 83       	std	Z+5, r21	; 0x05
    1258:	66 83       	std	Z+6, r22	; 0x06
    125a:	77 83       	std	Z+7, r23	; 0x07
    125c:	82 e2       	ldi	r24, 0x22	; 34
    125e:	9a e9       	ldi	r25, 0x9A	; 154
    1260:	80 83       	st	Z, r24
    1262:	91 83       	std	Z+1, r25	; 0x01
    1264:	80 e0       	ldi	r24, 0x00	; 0
    1266:	98 e0       	ldi	r25, 0x08	; 8
    1268:	84 87       	std	Z+12, r24	; 0x0c
    126a:	95 87       	std	Z+13, r25	; 0x0d
    126c:	84 e0       	ldi	r24, 0x04	; 4
    126e:	86 87       	std	Z+14, r24	; 0x0e
    1270:	85 e0       	ldi	r24, 0x05	; 5
    1272:	87 87       	std	Z+15, r24	; 0x0f
    1274:	10 8a       	std	Z+16, r1	; 0x10
    1276:	89 e0       	ldi	r24, 0x09	; 9
    1278:	81 8b       	std	Z+17, r24	; 0x11
    127a:	88 e0       	ldi	r24, 0x08	; 8
    127c:	82 8b       	std	Z+18, r24	; 0x12
    127e:	81 e0       	ldi	r24, 0x01	; 1
    1280:	83 8b       	std	Z+19, r24	; 0x13
    1282:	14 8a       	std	Z+20, r1	; 0x14
    1284:	15 8a       	std	Z+21, r1	; 0x15
    1286:	16 8a       	std	Z+22, r1	; 0x16
    1288:	17 8a       	std	Z+23, r1	; 0x17
    128a:	10 8e       	std	Z+24, r1	; 0x18
    128c:	11 8e       	std	Z+25, r1	; 0x19
    128e:	9c e1       	ldi	r25, 0x1C	; 28
    1290:	92 8f       	std	Z+26, r25	; 0x1a
    1292:	ed e1       	ldi	r30, 0x1D	; 29
    1294:	fa e3       	ldi	r31, 0x3A	; 58
    1296:	12 82       	std	Z+2, r1	; 0x02
    1298:	13 82       	std	Z+3, r1	; 0x03
    129a:	44 83       	std	Z+4, r20	; 0x04
    129c:	55 83       	std	Z+5, r21	; 0x05
    129e:	66 83       	std	Z+6, r22	; 0x06
    12a0:	77 83       	std	Z+7, r23	; 0x07
    12a2:	2c e3       	ldi	r18, 0x3C	; 60
    12a4:	3a e9       	ldi	r19, 0x9A	; 154
    12a6:	20 83       	st	Z, r18
    12a8:	31 83       	std	Z+1, r19	; 0x01
    12aa:	ed e4       	ldi	r30, 0x4D	; 77
    12ac:	fa e3       	ldi	r31, 0x3A	; 58
    12ae:	15 82       	std	Z+5, r1	; 0x05
    12b0:	29 e2       	ldi	r18, 0x29	; 41
    12b2:	3a e3       	ldi	r19, 0x3A	; 58
    12b4:	26 83       	std	Z+6, r18	; 0x06
    12b6:	37 83       	std	Z+7, r19	; 0x07
    12b8:	14 86       	std	Z+12, r1	; 0x0c
    12ba:	15 86       	std	Z+13, r1	; 0x0d
    12bc:	16 86       	std	Z+14, r1	; 0x0e
    12be:	17 86       	std	Z+15, r1	; 0x0f
    12c0:	83 87       	std	Z+11, r24	; 0x0b
    12c2:	80 87       	std	Z+8, r24	; 0x08
    12c4:	11 86       	std	Z+9, r1	; 0x09
    12c6:	92 e0       	ldi	r25, 0x02	; 2
    12c8:	92 87       	std	Z+10, r25	; 0x0a
    12ca:	24 e2       	ldi	r18, 0x24	; 36
    12cc:	30 e0       	ldi	r19, 0x00	; 0
    12ce:	22 83       	std	Z+2, r18	; 0x02
    12d0:	33 83       	std	Z+3, r19	; 0x03
    12d2:	2c e0       	ldi	r18, 0x0C	; 12
    12d4:	30 e0       	ldi	r19, 0x00	; 0
    12d6:	20 83       	st	Z, r18
    12d8:	31 83       	std	Z+1, r19	; 0x01
    12da:	84 83       	std	Z+4, r24	; 0x04
    12dc:	84 e0       	ldi	r24, 0x04	; 4
    12de:	94 e0       	ldi	r25, 0x04	; 4
    12e0:	80 8b       	std	Z+16, r24	; 0x10
    12e2:	91 8b       	std	Z+17, r25	; 0x11
    12e4:	80 e2       	ldi	r24, 0x20	; 32
    12e6:	82 8b       	std	Z+18, r24	; 0x12
    12e8:	08 95       	ret

000012ea <main>:
main():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/main.cpp:41
// has been ported to AVRxt, so you never know!

void setupUSB() __attribute__((weak));
void setupUSB() { }

int main(void) {
    12ea:	cf 93       	push	r28
    12ec:	df 93       	push	r29
    12ee:	cd b7       	in	r28, 0x3d	; 61
    12f0:	de b7       	in	r29, 0x3e	; 62
    12f2:	a3 97       	sbiw	r28, 0x23	; 35
    12f4:	cd bf       	out	0x3d, r28	; 61
    12f6:	de bf       	out	0x3e, r29	; 62
init():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:570

  /******************************** CLOCK STUFF *********************************/
  #if (CLOCK_SOURCE==0)
  #if (F_CPU == 20000000)
  /* No division on clock */
  _PROTECTED_WRITE(CLKCTRL_MCLKCTRLB, 0x00);
    12f8:	88 ed       	ldi	r24, 0xD8	; 216
    12fa:	90 e0       	ldi	r25, 0x00	; 0
    12fc:	84 bf       	out	0x34, r24	; 52
    12fe:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <digital_pin_to_port+0x7f660d>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:624
    be connected to the pin for longer, though the datasheet does not explicitly
    state that this is the case. However, we can use the SAMPLEN register to
    compensate for this! */

  #if F_CPU >= 12000000 // 16 MHz / 16 = 1 MHz,  20 MHz / 16 = 1.25 MHz
  ADC0.CTRLC = ADC_PRESC_DIV16_gc | ADC_REFSEL_VDDREF_gc | ADC_SAMPCAP_bm;;
    1302:	83 e5       	ldi	r24, 0x53	; 83
    1304:	80 93 02 06 	sts	0x0602, r24	; 0x800602 <digital_pin_to_port+0x7f6bae>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:632
  #elif F_CPU >= 3000000 // 4 MHz / 32 = 1 MHz, 5 MHz / 32 = 1.25 MHz
  ADC0.CTRLC = ADC_PRESC_DIV4_gc | ADC_REFSEL_VDDREF_gc | ADC_SAMPCAP_bm;;
  #else  // 1 MHz / 2 = 500 kHz - the lowest setting
  ADC0.CTRLC = ADC_PRESC_DIV2_gc | ADC_REFSEL_VDDREF_gc | ADC_SAMPCAP_bm;;
  #endif
  ADC0.SAMPCTRL = 14; //16 ADC clock sampling time - should be about the same amount of *time* as originally?
    1308:	8e e0       	ldi	r24, 0x0E	; 14
    130a:	80 93 05 06 	sts	0x0605, r24	; 0x800605 <digital_pin_to_port+0x7f6bb1>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:649
  ADC0.CTRLC = ADC_PRESC_DIV8_gc | ADC_REFSEL_VDDREF_gc | ADC_SAMPCAP_bm;;
  #else // 128 kHz / 2 = 64 kHz -> This is the closest you can get, the prescaler is 2
  ADC0.CTRLC = ADC_PRESC_DIV2_gc | ADC_REFSEL_VDDREF_gc | ADC_SAMPCAP_bm;;
  #endif
  #endif
  ADC0.CTRLD = ADC_INITDLY_DLY16_gc;
    130e:	80 e2       	ldi	r24, 0x20	; 32
    1310:	80 93 03 06 	sts	0x0603, r24	; 0x800603 <digital_pin_to_port+0x7f6baf>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:651
  /* Enable ADC */
  ADC0.CTRLA |= ADC_ENABLE_bm;
    1314:	80 91 00 06 	lds	r24, 0x0600	; 0x800600 <digital_pin_to_port+0x7f6bac>
    1318:	81 60       	ori	r24, 0x01	; 1
    131a:	80 93 00 06 	sts	0x0600, r24	; 0x800600 <digital_pin_to_port+0x7f6bac>
setup_timers():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:719

  /* PORTMUX setting for TCA - don't need to set because using default */
  //PORTMUX.CTRLA = PORTMUX_TCA00_DEFAULT_gc;

  /* Enable Split Mode */
  TCA0.SPLIT.CTRLD = TCA_SPLIT_SPLITM_bm;
    131e:	11 e0       	ldi	r17, 0x01	; 1
    1320:	10 93 03 0a 	sts	0x0A03, r17	; 0x800a03 <digital_pin_to_port+0x7f6faf>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:724

  //Only 1 WGM so no need to specifically set up.

  /* Period setting, 8-bit register in SPLIT mode */
  TCA0.SPLIT.LPER    = PWM_TIMER_PERIOD;
    1324:	8e ef       	ldi	r24, 0xFE	; 254
    1326:	80 93 26 0a 	sts	0x0A26, r24	; 0x800a26 <digital_pin_to_port+0x7f6fd2>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:725
  TCA0.SPLIT.HPER    = PWM_TIMER_PERIOD;
    132a:	80 93 27 0a 	sts	0x0A27, r24	; 0x800a27 <digital_pin_to_port+0x7f6fd3>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:733
  // 12/3/20: I think at most one could save 18 bytes here by
  // rewriting this in assembly. Not worth it. Removed the
  // TODO about making it a loop.
  // 12/3/20: start off with the compare registers set to 0.

  TCA0.SPLIT.LCMP0 = 0;
    132e:	10 92 28 0a 	sts	0x0A28, r1	; 0x800a28 <digital_pin_to_port+0x7f6fd4>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:734
  TCA0.SPLIT.HCMP0 = 0;
    1332:	10 92 29 0a 	sts	0x0A29, r1	; 0x800a29 <digital_pin_to_port+0x7f6fd5>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:735
  TCA0.SPLIT.LCMP1 = 0;
    1336:	10 92 2a 0a 	sts	0x0A2A, r1	; 0x800a2a <digital_pin_to_port+0x7f6fd6>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:736
  TCA0.SPLIT.HCMP1 = 0;
    133a:	10 92 2b 0a 	sts	0x0A2B, r1	; 0x800a2b <digital_pin_to_port+0x7f6fd7>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:737
  TCA0.SPLIT.LCMP2 = 0;
    133e:	10 92 2c 0a 	sts	0x0A2C, r1	; 0x800a2c <digital_pin_to_port+0x7f6fd8>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:738
  TCA0.SPLIT.HCMP2 = 0;
    1342:	10 92 2d 0a 	sts	0x0A2D, r1	; 0x800a2d <digital_pin_to_port+0x7f6fd9>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:744

  /* Use prescale appropriate for system clock speed */
  #if (F_CPU > 30000000) //use 256 divider when clocked over 30 MHz - probably not relevant on these parts, but hey, maybe they work at 32 on external clock - haven't tested!
  TCA0.SPLIT.CTRLA = (TCA_SPLIT_CLKSEL_DIV256_gc) | (TCA_SPLIT_ENABLE_bm);
  #elif (F_CPU > 5000000) //use 64 divider
  TCA0.SPLIT.CTRLA = (TCA_SPLIT_CLKSEL_DIV64_gc) | (TCA_SPLIT_ENABLE_bm);
    1346:	8b e0       	ldi	r24, 0x0B	; 11
    1348:	80 93 00 0a 	sts	0x0A00, r24	; 0x800a00 <digital_pin_to_port+0x7f6fac>
init_millis():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:513

void init_millis() {
  #if defined(MILLIS_USE_TIMERA0)
  TCA0.SPLIT.INTCTRL |= TCA_SPLIT_HUNF_bm;
  #elif defined(MILLIS_USE_TIMERD0)
  TCD0.CMPBCLR = TIME_TRACKING_TIMER_PERIOD; //essentially, this is TOP
    134c:	8d ef       	ldi	r24, 0xFD	; 253
    134e:	91 e0       	ldi	r25, 0x01	; 1
    1350:	80 93 ae 0a 	sts	0x0AAE, r24	; 0x800aae <digital_pin_to_port+0x7f705a>
    1354:	90 93 af 0a 	sts	0x0AAF, r25	; 0x800aaf <digital_pin_to_port+0x7f705b>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:514
  TCD0.INTCTRL = 0x01; //enable interrupt
    1358:	10 93 8c 0a 	sts	0x0A8C, r17	; 0x800a8c <digital_pin_to_port+0x7f7038>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:515
  TCD0.CTRLB = 0x00; //oneramp mode
    135c:	10 92 81 0a 	sts	0x0A81, r1	; 0x800a81 <digital_pin_to_port+0x7f702d>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:516
  TCD0.CTRLC = 0x80;
    1360:	80 e8       	ldi	r24, 0x80	; 128
    1362:	80 93 82 0a 	sts	0x0A82, r24	; 0x800a82 <digital_pin_to_port+0x7f702e>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:517
  TCD0.CTRLA = TIMERD0_PRESCALER | 0x01; //set clock source and enable!
    1366:	81 e1       	ldi	r24, 0x11	; 17
    1368:	80 93 80 0a 	sts	0x0A80, r24	; 0x800a80 <digital_pin_to_port+0x7f702c>
init():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:665
  #ifndef MILLIS_USE_TIMERNONE
  init_millis();
  #endif //end #ifndef MILLIS_USE_TIMERNONE
  /*************************** ENABLE GLOBAL INTERRUPTS *************************/

  sei();
    136c:	78 94       	sei
setup():
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:62
volatile byte state   = 0;
long lastButtonPress = 0;
volatile bool nextState       = false;
volatile bool readBuffer      = false;
void setup() {
  pinMode(TPU_PMIC_EN, OUTPUT);
    136e:	61 e0       	ldi	r22, 0x01	; 1
    1370:	82 e0       	ldi	r24, 0x02	; 2
    1372:	0e 94 b9 05 	call	0xb72	; 0xb72 <pinMode>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:63
  pinMode(TPU_RST_L,   OUTPUT);
    1376:	61 e0       	ldi	r22, 0x01	; 1
    1378:	88 e0       	ldi	r24, 0x08	; 8
    137a:	0e 94 b9 05 	call	0xb72	; 0xb72 <pinMode>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:64
  digitalWrite(TPU_PMIC_EN, LOW);
    137e:	60 e0       	ldi	r22, 0x00	; 0
    1380:	82 e0       	ldi	r24, 0x02	; 2
    1382:	0e 94 47 05 	call	0xa8e	; 0xa8e <digitalWrite>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:65
  digitalWrite(TPU_RST_L, LOW);
    1386:	60 e0       	ldi	r22, 0x00	; 0
    1388:	88 e0       	ldi	r24, 0x08	; 8
    138a:	0e 94 47 05 	call	0xa8e	; 0xa8e <digitalWrite>
begin():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src/Wire.cpp:148

  TWI_MasterInit(DEFAULT_FREQUENCY);
}

void TwoWire::begin(uint8_t address, bool receive_broadcast, uint8_t second_address) {
  rxBufferIndex = 0;
    138e:	10 92 65 38 	sts	0x3865, r1	; 0x803865 <TwoWire::rxBufferIndex>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src/Wire.cpp:149
  rxBufferLength = 0;
    1392:	10 92 64 38 	sts	0x3864, r1	; 0x803864 <TwoWire::rxBufferLength>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src/Wire.cpp:151

  txBufferIndex = 0;
    1396:	10 92 63 38 	sts	0x3863, r1	; 0x803863 <TwoWire::txBufferIndex>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src/Wire.cpp:152
  txBufferLength = 0;
    139a:	10 92 62 38 	sts	0x3862, r1	; 0x803862 <TwoWire::txBufferLength>
TWI_SlaveInit():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:99

    \param address            The TWI Slave's own address.
*/

void TWI_SlaveInit(uint8_t address, uint8_t receive_broadcast, uint8_t second_address) {
  if (twi_mode != TWI_MODE_UNKNOWN) {
    139e:	80 91 21 38 	lds	r24, 0x3821	; 0x803821 <twi_mode>
    13a2:	81 11       	cpse	r24, r1
    13a4:	19 c0       	rjmp	.+50     	; 0x13d8 <main+0xee>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:103
    return;
  }

  twi_mode = TWI_MODE_SLAVE;
    13a6:	82 e0       	ldi	r24, 0x02	; 2
    13a8:	80 93 21 38 	sts	0x3821, r24	; 0x803821 <twi_mode>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:105

  slave_bytesRead = 0;
    13ac:	10 92 20 38 	sts	0x3820, r1	; 0x803820 <slave_bytesRead>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:106
  slave_bytesWritten = 0;
    13b0:	10 92 1f 38 	sts	0x381F, r1	; 0x80381f <slave_bytesWritten>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:107
  slave_trans_status = TWIS_STATUS_READY;
    13b4:	10 92 1e 38 	sts	0x381E, r1	; 0x80381e <slave_trans_status>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:108
  slave_result = TWIS_RESULT_UNKNOWN;
    13b8:	10 92 1d 38 	sts	0x381D, r1	; 0x80381d <slave_result>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:109
  slave_callUserRequest = 0;
    13bc:	10 92 1c 38 	sts	0x381C, r1	; 0x80381c <slave_callUserRequest>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:110
  slave_callUserReceive = 0;
    13c0:	10 92 1b 38 	sts	0x381B, r1	; 0x80381b <slave_callUserReceive>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:112

  TWI0.SADDR = address << 1 | receive_broadcast;
    13c4:	88 e0       	ldi	r24, 0x08	; 8
    13c6:	80 93 1c 08 	sts	0x081C, r24	; 0x80081c <digital_pin_to_port+0x7f6dc8>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:113
  TWI0.SADDRMASK = second_address;
    13ca:	10 92 1e 08 	sts	0x081E, r1	; 0x80081e <digital_pin_to_port+0x7f6dca>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:114
  TWI0.SCTRLA = TWI_DIEN_bm | TWI_APIEN_bm | TWI_PIEN_bm  | TWI_ENABLE_bm;
    13ce:	81 ee       	ldi	r24, 0xE1	; 225
    13d0:	80 93 19 08 	sts	0x0819, r24	; 0x800819 <digital_pin_to_port+0x7f6dc5>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:117

  /* Bus Error Detection circuitry needs Master enabled to work */
  TWI0.MCTRLA = TWI_ENABLE_bm;
    13d4:	10 93 13 08 	sts	0x0813, r17	; 0x800813 <digital_pin_to_port+0x7f6dbf>
TWI_attachSlaveTxEvent():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:743
   Desc     sets function called before a slave write operation
   Input    function: callback function to use
   Output   none
*/
void TWI_attachSlaveTxEvent(uint8_t (*function)(void), uint8_t *write_data) {
  TWI_onSlaveTransmit = function;
    13d8:	85 ec       	ldi	r24, 0xC5	; 197
    13da:	92 e0       	ldi	r25, 0x02	; 2
    13dc:	80 93 19 38 	sts	0x3819, r24	; 0x803819 <TWI_onSlaveTransmit>
    13e0:	90 93 1a 38 	sts	0x381A, r25	; 0x80381a <TWI_onSlaveTransmit+0x1>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:744
  slave_writeData = write_data;
    13e4:	82 e4       	ldi	r24, 0x42	; 66
    13e6:	98 e3       	ldi	r25, 0x38	; 56
    13e8:	80 93 17 38 	sts	0x3817, r24	; 0x803817 <slave_writeData>
    13ec:	90 93 18 38 	sts	0x3818, r25	; 0x803818 <slave_writeData+0x1>
TWI_attachSlaveRxEvent():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:731
   Desc     sets function called before a slave read operation
   Input    function: callback function to use
   Output   none
*/
void TWI_attachSlaveRxEvent(void (*function)(int), uint8_t *read_data, uint8_t bytes_to_read) {
  TWI_onSlaveReceive = function;
    13f0:	85 ed       	ldi	r24, 0xD5	; 213
    13f2:	92 e0       	ldi	r25, 0x02	; 2
    13f4:	80 93 15 38 	sts	0x3815, r24	; 0x803815 <TWI_onSlaveReceive>
    13f8:	90 93 16 38 	sts	0x3816, r25	; 0x803816 <TWI_onSlaveReceive+0x1>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:732
  slave_readData = read_data;
    13fc:	82 e2       	ldi	r24, 0x22	; 34
    13fe:	98 e3       	ldi	r25, 0x38	; 56
    1400:	80 93 13 38 	sts	0x3813, r24	; 0x803813 <slave_readData>
    1404:	90 93 14 38 	sts	0x3814, r25	; 0x803814 <slave_readData+0x1>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src\utility/twi.c:733
  slave_bytesToRead = bytes_to_read;
    1408:	80 e2       	ldi	r24, 0x20	; 32
    140a:	80 93 12 38 	sts	0x3812, r24	; 0x803812 <slave_bytesToRead>
onReceive():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src/Wire.cpp:396
  return txBufferLength;
}

// sets function called on slave write
void TwoWire::onReceive(void (*function)(int)) {
  user_onReceive = function;
    140e:	8d e0       	ldi	r24, 0x0D	; 13
    1410:	96 e0       	ldi	r25, 0x06	; 6
    1412:	80 93 66 38 	sts	0x3866, r24	; 0x803866 <TwoWire::user_onReceive>
    1416:	90 93 67 38 	sts	0x3867, r25	; 0x803867 <TwoWire::user_onReceive+0x1>
onRequest():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\Wire\src/Wire.cpp:401
}

// sets function called on slave read
void TwoWire::onRequest(void (*function)(void)) {
  user_onRequest = function;
    141a:	8f e9       	ldi	r24, 0x9F	; 159
    141c:	94 e0       	ldi	r25, 0x04	; 4
    141e:	80 93 68 38 	sts	0x3868, r24	; 0x803868 <TwoWire::user_onRequest>
    1422:	90 93 69 38 	sts	0x3869, r25	; 0x803869 <TwoWire::user_onRequest+0x1>
setup():
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:70
  
  Wire.begin(4);                // join i2c bus with address #4
  Wire.onReceive(receiveEvent); // register event
  Wire.onRequest(requestEvent);
  pinMode(NEOXPIXELPIN,OUTPUT);
    1426:	61 e0       	ldi	r22, 0x01	; 1
    1428:	81 e0       	ldi	r24, 0x01	; 1
    142a:	0e 94 b9 05 	call	0xb72	; 0xb72 <pinMode>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:71
  pinMode(FAN_PWM  ,   OUTPUT);
    142e:	61 e0       	ldi	r22, 0x01	; 1
    1430:	80 e0       	ldi	r24, 0x00	; 0
    1432:	0e 94 b9 05 	call	0xb72	; 0xb72 <pinMode>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:72
  pinMode(FAN_TACH ,   INPUT); 
    1436:	60 e0       	ldi	r22, 0x00	; 0
    1438:	8a e0       	ldi	r24, 0x0A	; 10
    143a:	0e 94 b9 05 	call	0xb72	; 0xb72 <pinMode>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:73
  pinMode(TPU_PGOOD,   INPUT);
    143e:	60 e0       	ldi	r22, 0x00	; 0
    1440:	89 e0       	ldi	r24, 0x09	; 9
    1442:	0e 94 b9 05 	call	0xb72	; 0xb72 <pinMode>
setBrightness():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.cpp:1106
  // 8x8-bit multiply and taking the MSB.  'brightness' is a uint8_t,
  // adding 1 here may (intentionally) roll over...so 0 = max brightness
  // (color values are interpreted literally; no scaling), 1 = min
  // brightness (off), 255 = just below max brightness.
  uint8_t newBrightness = b + 1;
  if (newBrightness != brightness) { // Compare against prior value
    1446:	60 91 52 3a 	lds	r22, 0x3A52	; 0x803a52 <strip+0x5>
    144a:	65 36       	cpi	r22, 0x65	; 101
    144c:	29 f1       	breq	.+74     	; 0x1498 <main+0x1ae>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.cpp:1109
    // Brightness has changed -- re-scale existing data in RAM
    uint8_t  c,
            *ptr           = pixels,
    144e:	20 91 53 3a 	lds	r18, 0x3A53	; 0x803a53 <strip+0x6>
    1452:	30 91 54 3a 	lds	r19, 0x3A54	; 0x803a54 <strip+0x7>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.cpp:1110
             oldBrightness = brightness - 1; // De-wrap old brightness value
    1456:	61 50       	subi	r22, 0x01	; 1
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.cpp:1112
    uint16_t scale;
    if (oldBrightness == 0) {
    1458:	c9 f0       	breq	.+50     	; 0x148c <main+0x1a2>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.cpp:1117
      scale = 0;  // Avoid /0
    } else if (b == 255) {
      scale = 65535 / oldBrightness;
    } else {
      scale = (((uint16_t)newBrightness << 8) - 1) / oldBrightness;
    145a:	70 e0       	ldi	r23, 0x00	; 0
    145c:	8f ef       	ldi	r24, 0xFF	; 255
    145e:	94 e6       	ldi	r25, 0x64	; 100
    1460:	0e 94 a3 0c 	call	0x1946	; 0x1946 <__udivmodhi4>
main():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.cpp:1109
  // brightness (off), 255 = just below max brightness.
  uint8_t newBrightness = b + 1;
  if (newBrightness != brightness) { // Compare against prior value
    // Brightness has changed -- re-scale existing data in RAM
    uint8_t  c,
            *ptr           = pixels,
    1464:	f9 01       	movw	r30, r18
setBrightness():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.cpp:1119
    } else if (b == 255) {
      scale = 65535 / oldBrightness;
    } else {
      scale = (((uint16_t)newBrightness << 8) - 1) / oldBrightness;
    }
    for (uint16_t i = 0; i < numBytes; i++) {
    1466:	40 91 4f 3a 	lds	r20, 0x3A4F	; 0x803a4f <strip+0x2>
    146a:	50 91 50 3a 	lds	r21, 0x3A50	; 0x803a50 <strip+0x3>
    146e:	cf 01       	movw	r24, r30
    1470:	82 1b       	sub	r24, r18
    1472:	93 0b       	sbc	r25, r19
    1474:	84 17       	cp	r24, r20
    1476:	95 07       	cpc	r25, r21
    1478:	60 f4       	brcc	.+24     	; 0x1492 <main+0x1a8>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.cpp:1121
      c      = *ptr;
      *ptr++ = (c * scale) >> 8;
    147a:	40 81       	ld	r20, Z
    147c:	46 9f       	mul	r20, r22
    147e:	c0 01       	movw	r24, r0
    1480:	47 9f       	mul	r20, r23
    1482:	90 0d       	add	r25, r0
    1484:	11 24       	eor	r1, r1
    1486:	90 83       	st	Z, r25
main():
    1488:	31 96       	adiw	r30, 0x01	; 1
    148a:	ed cf       	rjmp	.-38     	; 0x1466 <main+0x17c>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.cpp:1113
    uint8_t  c,
            *ptr           = pixels,
             oldBrightness = brightness - 1; // De-wrap old brightness value
    uint16_t scale;
    if (oldBrightness == 0) {
      scale = 0;  // Avoid /0
    148c:	70 e0       	ldi	r23, 0x00	; 0
    148e:	60 e0       	ldi	r22, 0x00	; 0
    1490:	e9 cf       	rjmp	.-46     	; 0x1464 <main+0x17a>
setBrightness():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.cpp:1123
    }
    for (uint16_t i = 0; i < numBytes; i++) {
      c      = *ptr;
      *ptr++ = (c * scale) >> 8;
    }
    brightness = newBrightness;
    1492:	85 e6       	ldi	r24, 0x65	; 101
    1494:	80 93 52 3a 	sts	0x3A52, r24	; 0x803a52 <strip+0x5>
setup():
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:90
  
  //if(digitalRead(TPU_PGOOD)){
    //digitalWrite(TPU_RST_L, HIGH);  
  //}
  strip.setBrightness(BRIGHTNESS);
  strip.show(); // Initialize all pixels to 'off'
    1498:	0e 94 53 03 	call	0x6a6	; 0x6a6 <tinyNeoPixel::show() [clone .constprop.18]>
setFan():
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:241
 */
void setFan(byte fanSpeed){

  // FAN_PWM at zero turns on Fan
  // invert input so 255 is full on, zero is off
  analogWrite(FAN_PWM, constrain(255 - fanSpeed, 0, 255));
    149c:	8f ef       	ldi	r24, 0xFF	; 255
    149e:	90 e0       	ldi	r25, 0x00	; 0
    14a0:	0e 94 f0 05 	call	0xbe0	; 0xbe0 <analogWrite.constprop.21>
setup():
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:93
  //}
  strip.setBrightness(BRIGHTNESS);
  strip.show(); // Initialize all pixels to 'off'
  
  setFan(0); // Start Fan as off
  Serial.begin(57600); 
    14a4:	40 e0       	ldi	r20, 0x00	; 0
    14a6:	51 ee       	ldi	r21, 0xE1	; 225
    14a8:	60 e0       	ldi	r22, 0x00	; 0
    14aa:	70 e0       	ldi	r23, 0x00	; 0
    14ac:	82 e8       	ldi	r24, 0x82	; 130
    14ae:	99 e3       	ldi	r25, 0x39	; 57
    14b0:	0e 94 19 05 	call	0xa32	; 0xa32 <UartClass::begin(unsigned long)>
write():
    14b4:	8b e6       	ldi	r24, 0x6B	; 107
    14b6:	9a e9       	ldi	r25, 0x9A	; 154
    14b8:	0e 94 22 05 	call	0xa44	; 0xa44 <Print::write(char const*) [clone .part.2] [clone .constprop.30]>
    14bc:	88 e6       	ldi	r24, 0x68	; 104
    14be:	9a e9       	ldi	r25, 0x9A	; 154
    14c0:	0e 94 22 05 	call	0xa44	; 0xa44 <Print::write(char const*) [clone .part.2] [clone .constprop.30]>
operator*():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\EEPROM\src/EEPROM.h:43
  EERef(const uint8_t index)
    : index(index)                 {}

  //Access/read members.
  uint8_t operator*() const            {
    return eeprom_read_byte((uint8_t *)(uint16_t) index);
    14c4:	90 e0       	ldi	r25, 0x00	; 0
    14c6:	80 e0       	ldi	r24, 0x00	; 0
    14c8:	0e 94 87 0c 	call	0x190e	; 0x190e <eeprom_read_byte>
_ZN11EEPROMClass3getIjEERT_iS2_.isra.3():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\EEPROM\src/EEPROM.h:198
  //Functionality to 'get' and 'put' objects to and from EEPROM.
  template< typename T > T &get(int idx, T &t) {
    EEPtr e = idx;
    uint8_t *ptr = (uint8_t *) &t;
    for (int count = sizeof(T) ; count ; --count, ++e) {
      *ptr++ = *e;
    14cc:	80 93 6a 38 	sts	0x386A, r24	; 0x80386a <numBootsVal>
operator*():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\EEPROM\src/EEPROM.h:43
  EERef(const uint8_t index)
    : index(index)                 {}

  //Access/read members.
  uint8_t operator*() const            {
    return eeprom_read_byte((uint8_t *)(uint16_t) index);
    14d0:	81 e0       	ldi	r24, 0x01	; 1
    14d2:	90 e0       	ldi	r25, 0x00	; 0
    14d4:	0e 94 87 0c 	call	0x190e	; 0x190e <eeprom_read_byte>
_ZN11EEPROMClass3getIjEERT_iS2_.isra.3():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\EEPROM\src/EEPROM.h:198
  //Functionality to 'get' and 'put' objects to and from EEPROM.
  template< typename T > T &get(int idx, T &t) {
    EEPtr e = idx;
    uint8_t *ptr = (uint8_t *) &t;
    for (int count = sizeof(T) ; count ; --count, ++e) {
      *ptr++ = *e;
    14d8:	80 93 6b 38 	sts	0x386B, r24	; 0x80386b <numBootsVal+0x1>
readNumBoots():
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:196
}
unsigned int numBootsVal = 0;
void readNumBoots(){
  EEPROM.get(NUM_BOOTS, numBootsVal);
 
  numBootsVal += 6;
    14dc:	00 91 6a 38 	lds	r16, 0x386A	; 0x80386a <numBootsVal>
    14e0:	10 91 6b 38 	lds	r17, 0x386B	; 0x80386b <numBootsVal+0x1>
    14e4:	0a 5f       	subi	r16, 0xFA	; 250
    14e6:	1f 4f       	sbci	r17, 0xFF	; 255
    14e8:	00 93 6a 38 	sts	0x386A, r16	; 0x80386a <numBootsVal>
    14ec:	10 93 6b 38 	sts	0x386B, r17	; 0x80386b <numBootsVal+0x1>
operator*():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\EEPROM\src/EEPROM.h:43
  EERef(const uint8_t index)
    : index(index)                 {}

  //Access/read members.
  uint8_t operator*() const            {
    return eeprom_read_byte((uint8_t *)(uint16_t) index);
    14f0:	90 e0       	ldi	r25, 0x00	; 0
    14f2:	80 e0       	ldi	r24, 0x00	; 0
    14f4:	0e 94 87 0c 	call	0x190e	; 0x190e <eeprom_read_byte>
update():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\EEPROM\src/EEPROM.h:88
  EERef &operator >>=(uint8_t in)    {
    return *this = **this >> in;
  }

  EERef &update(uint8_t in)          {
    return  in != *this ? *this = in : *this;
    14f8:	80 17       	cp	r24, r16
    14fa:	29 f0       	breq	.+10     	; 0x1506 <main+0x21c>
operator=():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\EEPROM\src/EEPROM.h:54
  //Assignment/write members.
  EERef &operator=(const EERef &ref) {
    return *this = *ref;
  }
  EERef &operator=(uint8_t in)       {
    return eeprom_write_byte((uint8_t *)(uint16_t) index, in), *this;
    14fc:	60 2f       	mov	r22, r16
    14fe:	90 e0       	ldi	r25, 0x00	; 0
    1500:	80 e0       	ldi	r24, 0x00	; 0
    1502:	0e 94 8f 0c 	call	0x191e	; 0x191e <eeprom_write_byte>
_ZN11EEPROMClass3putIjEERKT_iS3_.isra.4():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\EEPROM\src/EEPROM.h:207

  template< typename T > const T &put(int idx, const T &t) {
    EEPtr e = idx;
    const uint8_t *ptr = (const uint8_t *) &t;
    for (int count = sizeof(T) ; count ; --count, ++e) {
      (*e).update(*ptr++);
    1506:	10 91 6b 38 	lds	r17, 0x386B	; 0x80386b <numBootsVal+0x1>
operator*():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\EEPROM\src/EEPROM.h:43
  EERef(const uint8_t index)
    : index(index)                 {}

  //Access/read members.
  uint8_t operator*() const            {
    return eeprom_read_byte((uint8_t *)(uint16_t) index);
    150a:	81 e0       	ldi	r24, 0x01	; 1
    150c:	90 e0       	ldi	r25, 0x00	; 0
    150e:	0e 94 87 0c 	call	0x190e	; 0x190e <eeprom_read_byte>
update():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\EEPROM\src/EEPROM.h:88
  EERef &operator >>=(uint8_t in)    {
    return *this = **this >> in;
  }

  EERef &update(uint8_t in)          {
    return  in != *this ? *this = in : *this;
    1512:	18 17       	cp	r17, r24
    1514:	29 f0       	breq	.+10     	; 0x1520 <main+0x236>
operator=():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\EEPROM\src/EEPROM.h:54
  //Assignment/write members.
  EERef &operator=(const EERef &ref) {
    return *this = *ref;
  }
  EERef &operator=(uint8_t in)       {
    return eeprom_write_byte((uint8_t *)(uint16_t) index, in), *this;
    1516:	61 2f       	mov	r22, r17
    1518:	81 e0       	ldi	r24, 0x01	; 1
    151a:	90 e0       	ldi	r25, 0x00	; 0
    151c:	0e 94 8f 0c 	call	0x191e	; 0x191e <eeprom_write_byte>
write():
    1520:	8c e7       	ldi	r24, 0x7C	; 124
    1522:	9a e9       	ldi	r25, 0x9A	; 154
    1524:	0e 94 22 05 	call	0xa44	; 0xa44 <Print::write(char const*) [clone .part.2] [clone .constprop.30]>
print():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore\api/Print.cpp:83
size_t Print::print(int n, int base) {
  return print((long) n, base);
}

size_t Print::print(unsigned int n, int base) {
  return print((unsigned long) n, base);
    1528:	20 91 6a 38 	lds	r18, 0x386A	; 0x80386a <numBootsVal>
    152c:	30 91 6b 38 	lds	r19, 0x386B	; 0x80386b <numBootsVal+0x1>
    1530:	50 e0       	ldi	r21, 0x00	; 0
    1532:	40 e0       	ldi	r20, 0x00	; 0
printNumber():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore\api/Print.cpp:219

size_t Print::printNumber(unsigned long n, uint8_t base) {
  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
    1534:	19 a2       	std	Y+33, r1	; 0x21
    1536:	8e 01       	movw	r16, r28
    1538:	0f 5d       	subi	r16, 0xDF	; 223
    153a:	1f 4f       	sbci	r17, 0xFF	; 255
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore\api/Print.cpp:227
  if (base < 2) {
    base = 10;
  }

  do {
    char c = n % base;
    153c:	8a e0       	ldi	r24, 0x0A	; 10
    153e:	c8 2e       	mov	r12, r24
    1540:	d1 2c       	mov	r13, r1
    1542:	e1 2c       	mov	r14, r1
    1544:	f1 2c       	mov	r15, r1
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore\api/Print.cpp:228
    n /= base;
    1546:	ca 01       	movw	r24, r20
    1548:	b9 01       	movw	r22, r18
    154a:	a7 01       	movw	r20, r14
    154c:	96 01       	movw	r18, r12
    154e:	0e 94 b7 0c 	call	0x196e	; 0x196e <__udivmodsi4>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore\api/Print.cpp:230

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
    1552:	60 5d       	subi	r22, 0xD0	; 208
    1554:	f8 01       	movw	r30, r16
    1556:	62 93       	st	-Z, r22
    1558:	8f 01       	movw	r16, r30
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore\api/Print.cpp:231
  } while (n);
    155a:	21 15       	cp	r18, r1
    155c:	31 05       	cpc	r19, r1
    155e:	41 05       	cpc	r20, r1
    1560:	51 05       	cpc	r21, r1
    1562:	89 f7       	brne	.-30     	; 0x1546 <main+0x25c>
write():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore\api/Print.h:53
      setWriteError(0);
    }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) {
    1564:	30 97       	sbiw	r30, 0x00	; 0
    1566:	19 f0       	breq	.+6      	; 0x156e <main+0x284>
    1568:	cf 01       	movw	r24, r30
    156a:	0e 94 22 05 	call	0xa44	; 0xa44 <Print::write(char const*) [clone .part.2] [clone .constprop.30]>
    156e:	88 e6       	ldi	r24, 0x68	; 104
    1570:	9a e9       	ldi	r25, 0x9A	; 154
    1572:	0e 94 22 05 	call	0xa44	; 0xa44 <Print::write(char const*) [clone .part.2] [clone .constprop.30]>
readNumBoots():
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:202
  
  EEPROM.put(NUM_BOOTS, numBootsVal );
  
  Serial.print("BootNumber: ");
  Serial.println(numBootsVal);
  bufferI2C[0xF5] = numBootsVal >> 8 ;
    1576:	80 91 6a 38 	lds	r24, 0x386A	; 0x80386a <numBootsVal>
    157a:	90 91 6b 38 	lds	r25, 0x386B	; 0x80386b <numBootsVal+0x1>
    157e:	90 93 71 39 	sts	0x3971, r25	; 0x803971 <bufferI2C+0xf5>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:203
  bufferI2C[0xF6] = numBootsVal      ;
    1582:	80 93 72 39 	sts	0x3972, r24	; 0x803972 <bufferI2C+0xf6>
    1586:	bc e0       	ldi	r27, 0x0C	; 12
    1588:	6b 2e       	mov	r6, r27
serialEventRun():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:66
  bool Serial3_available() __attribute__((weak));
#endif

void serialEventRun(void) {
  #if defined(HAVE_HWSERIAL0)
  if (Serial0_available && serialEvent && Serial0_available()) {
    158a:	10 e0       	ldi	r17, 0x00	; 0
    158c:	81 2e       	mov	r8, r17
    158e:	10 e0       	ldi	r17, 0x00	; 0
    1590:	91 2e       	mov	r9, r17
loop():
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:164
      state = 9;
      break;
*/
    case 104:
      show_pattern();
      state = 255;
    1592:	ee 24       	eor	r14, r14
    1594:	ea 94       	dec	r14
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:101
  
  readNumBoots();
}

void loop() {
  switch(state){
    1596:	80 91 81 39 	lds	r24, 0x3981	; 0x803981 <state>
    159a:	89 30       	cpi	r24, 0x09	; 9
    159c:	08 f0       	brcs	.+2      	; 0x15a0 <main+0x2b6>
    159e:	55 c0       	rjmp	.+170    	; 0x164a <main+0x360>
    15a0:	87 30       	cpi	r24, 0x07	; 7
    15a2:	08 f0       	brcs	.+2      	; 0x15a6 <main+0x2bc>
    15a4:	a0 c0       	rjmp	.+320    	; 0x16e6 <main+0x3fc>
    15a6:	83 30       	cpi	r24, 0x03	; 3
    15a8:	09 f4       	brne	.+2      	; 0x15ac <main+0x2c2>
    15aa:	01 c1       	rjmp	.+514    	; 0x17ae <main+0x4c4>
    15ac:	58 f4       	brcc	.+22     	; 0x15c4 <main+0x2da>
    15ae:	81 30       	cpi	r24, 0x01	; 1
    15b0:	09 f4       	brne	.+2      	; 0x15b4 <main+0x2ca>
    15b2:	63 c0       	rjmp	.+198    	; 0x167a <main+0x390>
    15b4:	08 f4       	brcc	.+2      	; 0x15b8 <main+0x2ce>
    15b6:	8a c0       	rjmp	.+276    	; 0x16cc <main+0x3e2>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:116
      //colorWipe(strip.Color(0, 0, 0), 50); // 
   
      break;
    case 2:
      // Some example procedures showing how to display to the pixels:
      colorWipe(strip.Color(255, 0, 0), 50); // Red
    15b8:	42 e3       	ldi	r20, 0x32	; 50
    15ba:	60 e0       	ldi	r22, 0x00	; 0
    15bc:	70 e0       	ldi	r23, 0x00	; 0
    15be:	8f ef       	ldi	r24, 0xFF	; 255
    15c0:	90 e0       	ldi	r25, 0x00	; 0
    15c2:	89 c0       	rjmp	.+274    	; 0x16d6 <main+0x3ec>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:101
  
  readNumBoots();
}

void loop() {
  switch(state){
    15c4:	85 30       	cpi	r24, 0x05	; 5
    15c6:	09 f4       	brne	.+2      	; 0x15ca <main+0x2e0>
    15c8:	f8 c0       	rjmp	.+496    	; 0x17ba <main+0x4d0>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:124
    case 3:
      colorWipe(strip.Color(0, 255, 0), 50); // Green
      colorWipe(strip.Color(0, 0, 0), 50); // Red
      break;
    case 4:
      colorWipe(strip.Color(0, 0, 0), 0); // black
    15ca:	40 e0       	ldi	r20, 0x00	; 0
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:101
  
  readNumBoots();
}

void loop() {
  switch(state){
    15cc:	86 30       	cpi	r24, 0x06	; 6
    15ce:	08 f4       	brcc	.+2      	; 0x15d2 <main+0x2e8>
    15d0:	85 c0       	rjmp	.+266    	; 0x16dc <main+0x3f2>
    15d2:	f1 2c       	mov	r15, r1
    15d4:	00 e0       	ldi	r16, 0x00	; 0
main():
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:348


void rainbow(uint8_t wait) {
  uint16_t i, j;

  for(j=0; j<256 && !nextState; j++) {
    15d6:	b1 2c       	mov	r11, r1
    15d8:	a1 2c       	mov	r10, r1
rainbow():
    15da:	80 91 80 39 	lds	r24, 0x3980	; 0x803980 <nextState>
    15de:	81 11       	cpse	r24, r1
    15e0:	82 c0       	rjmp	.+260    	; 0x16e6 <main+0x3fc>
    15e2:	71 2c       	mov	r7, r1
    15e4:	10 e0       	ldi	r17, 0x00	; 0
main():
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:349
    for(i=0; i<strip.numPixels() && !nextState; i++) {
    15e6:	d1 2c       	mov	r13, r1
    15e8:	c1 2c       	mov	r12, r1
Wheel():
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:411
*/
// Input a value 0 to 255 to get a color value.
// The colours are a transition r - g - b - back to r.
uint32_t Wheel(byte WheelPos) {
  WheelPos = 255 - WheelPos;
  if(WheelPos < 85) {
    15ea:	2a 2c       	mov	r2, r10
    15ec:	20 94       	com	r2
_ZN12tinyNeoPixel5ColorEhhh():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.h:263
    15ee:	ff ef       	ldi	r31, 0xFF	; 255
    15f0:	f0 0f       	add	r31, r16
    15f2:	fa a3       	std	Y+34, r31	; 0x22
    15f4:	3e ef       	ldi	r19, 0xFE	; 254
    15f6:	53 2e       	mov	r5, r19
    15f8:	50 0e       	add	r5, r16
    15fa:	44 24       	eor	r4, r4
    15fc:	43 94       	inc	r4
    15fe:	4f 0c       	add	r4, r15
    1600:	42 e0       	ldi	r20, 0x02	; 2
    1602:	34 2e       	mov	r3, r20
    1604:	3f 0c       	add	r3, r15
    1606:	8d ef       	ldi	r24, 0xFD	; 253
    1608:	80 0f       	add	r24, r16
    160a:	8b a3       	std	Y+35, r24	; 0x23
rainbow():
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:349

void rainbow(uint8_t wait) {
  uint16_t i, j;

  for(j=0; j<256 && !nextState; j++) {
    for(i=0; i<strip.numPixels() && !nextState; i++) {
    160c:	80 91 4d 3a 	lds	r24, 0x3A4D	; 0x803a4d <strip>
    1610:	90 91 4e 3a 	lds	r25, 0x3A4E	; 0x803a4e <strip+0x1>
    1614:	c8 16       	cp	r12, r24
    1616:	d9 06       	cpc	r13, r25
    1618:	28 f4       	brcc	.+10     	; 0x1624 <main+0x33a>
    161a:	80 91 80 39 	lds	r24, 0x3980	; 0x803980 <nextState>
    161e:	88 23       	and	r24, r24
    1620:	09 f4       	brne	.+2      	; 0x1624 <main+0x33a>
    1622:	1a c1       	rjmp	.+564    	; 0x1858 <main+0x56e>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:352
      strip.setPixelColor(i, Wheel((i+j) & 255));
    }
    strip.show();
    1624:	0e 94 53 03 	call	0x6a6	; 0x6a6 <tinyNeoPixel::show() [clone .constprop.18]>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:353
    delay(wait);
    1628:	65 e0       	ldi	r22, 0x05	; 5
    162a:	70 e0       	ldi	r23, 0x00	; 0
    162c:	80 e0       	ldi	r24, 0x00	; 0
    162e:	90 e0       	ldi	r25, 0x00	; 0
    1630:	0e 94 d9 03 	call	0x7b2	; 0x7b2 <delay>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:348


void rainbow(uint8_t wait) {
  uint16_t i, j;

  for(j=0; j<256 && !nextState; j++) {
    1634:	9f ef       	ldi	r25, 0xFF	; 255
    1636:	a9 1a       	sub	r10, r25
    1638:	b9 0a       	sbc	r11, r25
    163a:	03 50       	subi	r16, 0x03	; 3
    163c:	e3 e0       	ldi	r30, 0x03	; 3
    163e:	fe 0e       	add	r15, r30
    1640:	a1 14       	cp	r10, r1
    1642:	f1 e0       	ldi	r31, 0x01	; 1
    1644:	bf 06       	cpc	r11, r31
    1646:	49 f6       	brne	.-110    	; 0x15da <main+0x2f0>
    1648:	4e c0       	rjmp	.+156    	; 0x16e6 <main+0x3fc>
loop():
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:101
  
  readNumBoots();
}

void loop() {
  switch(state){
    164a:	85 36       	cpi	r24, 0x65	; 101
    164c:	09 f4       	brne	.+2      	; 0x1650 <main+0x366>
    164e:	49 c1       	rjmp	.+658    	; 0x18e2 <main+0x5f8>
    1650:	40 f4       	brcc	.+16     	; 0x1662 <main+0x378>
    1652:	8a 30       	cpi	r24, 0x0A	; 10
    1654:	69 f0       	breq	.+26     	; 0x1670 <main+0x386>
    1656:	84 36       	cpi	r24, 0x64	; 100
    1658:	09 f4       	brne	.+2      	; 0x165c <main+0x372>
    165a:	31 c1       	rjmp	.+610    	; 0x18be <main+0x5d4>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:171
    case 202: 
    case 255:
      break;
    default:
      //colorWipe(strip.Color(0, 0, 0), 0); // black
      strip.show();
    165c:	0e 94 53 03 	call	0x6a6	; 0x6a6 <tinyNeoPixel::show() [clone .constprop.18]>
    1660:	42 c0       	rjmp	.+132    	; 0x16e6 <main+0x3fc>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:101
  
  readNumBoots();
}

void loop() {
  switch(state){
    1662:	8a 3c       	cpi	r24, 0xCA	; 202
    1664:	09 f4       	brne	.+2      	; 0x1668 <main+0x37e>
    1666:	3f c0       	rjmp	.+126    	; 0x16e6 <main+0x3fc>
    1668:	8f 3f       	cpi	r24, 0xFF	; 255
    166a:	e9 f1       	breq	.+122    	; 0x16e6 <main+0x3fc>
    166c:	88 36       	cpi	r24, 0x68	; 104
    166e:	b1 f7       	brne	.-20     	; 0x165c <main+0x372>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:163
      setup_crossfade();
      state = 9;
      break;
*/
    case 104:
      show_pattern();
    1670:	0e 94 ad 04 	call	0x95a	; 0x95a <show_pattern()>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:164
      state = 255;
    1674:	e0 92 81 39 	sts	0x3981, r14	; 0x803981 <state>
    1678:	36 c0       	rjmp	.+108    	; 0x16e6 <main+0x3fc>
    167a:	0c e7       	ldi	r16, 0x7C	; 124
    167c:	18 e3       	ldi	r17, 0x38	; 56
main():
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:286
    delay(wait);
  }
}

void showi2cPixels() {
  for(uint16_t i=0; i<strip.numPixels(); i++) {
    167e:	d1 2c       	mov	r13, r1
    1680:	c1 2c       	mov	r12, r1
showi2cPixels():
    1682:	80 91 4d 3a 	lds	r24, 0x3A4D	; 0x803a4d <strip>
    1686:	90 91 4e 3a 	lds	r25, 0x3A4E	; 0x803a4e <strip+0x1>
    168a:	c8 16       	cp	r12, r24
    168c:	d9 06       	cpc	r13, r25
    168e:	30 f7       	brcc	.-52     	; 0x165c <main+0x372>
_ZN12tinyNeoPixel5ColorEhhh():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.h:263
    1690:	f8 01       	movw	r30, r16
    1692:	80 81       	ld	r24, Z
    1694:	41 81       	ldd	r20, Z+1	; 0x01
    1696:	50 e0       	ldi	r21, 0x00	; 0
    1698:	70 e0       	ldi	r23, 0x00	; 0
    169a:	60 e0       	ldi	r22, 0x00	; 0
    169c:	76 2f       	mov	r23, r22
    169e:	65 2f       	mov	r22, r21
    16a0:	54 2f       	mov	r21, r20
    16a2:	44 27       	eor	r20, r20
    16a4:	68 2b       	or	r22, r24
    16a6:	82 81       	ldd	r24, Z+2	; 0x02
    16a8:	48 2b       	or	r20, r24
showi2cPixels():
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:287
    strip.setPixelColor(i, strip.Color(bufferI2C[i * 3], bufferI2C[i * 3+1], bufferI2C[i * 3+2]) ); // set color from i2c
    16aa:	c6 01       	movw	r24, r12
    16ac:	0e 94 5e 01 	call	0x2bc	; 0x2bc <tinyNeoPixel::setPixelColor(unsigned int, unsigned long) [clone .constprop.6]>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:288
    delay(10);
    16b0:	6a e0       	ldi	r22, 0x0A	; 10
    16b2:	70 e0       	ldi	r23, 0x00	; 0
    16b4:	80 e0       	ldi	r24, 0x00	; 0
    16b6:	90 e0       	ldi	r25, 0x00	; 0
    16b8:	0e 94 d9 03 	call	0x7b2	; 0x7b2 <delay>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:289
    strip.show();
    16bc:	0e 94 53 03 	call	0x6a6	; 0x6a6 <tinyNeoPixel::show() [clone .constprop.18]>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:286
    delay(wait);
  }
}

void showi2cPixels() {
  for(uint16_t i=0; i<strip.numPixels(); i++) {
    16c0:	ff ef       	ldi	r31, 0xFF	; 255
    16c2:	cf 1a       	sub	r12, r31
    16c4:	df 0a       	sbc	r13, r31
    16c6:	0d 5f       	subi	r16, 0xFD	; 253
    16c8:	1f 4f       	sbci	r17, 0xFF	; 255
    16ca:	db cf       	rjmp	.-74     	; 0x1682 <main+0x398>
loop():
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:103
}

void loop() {
  switch(state){
    case 0:
      colorWipe(strip.Color(34, 167, 240), 70 ); // Blue
    16cc:	46 e4       	ldi	r20, 0x46	; 70
    16ce:	60 ef       	ldi	r22, 0xF0	; 240
    16d0:	77 ea       	ldi	r23, 0xA7	; 167
    16d2:	82 e2       	ldi	r24, 0x22	; 34
    16d4:	90 e0       	ldi	r25, 0x00	; 0
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:116
      //colorWipe(strip.Color(0, 0, 0), 50); // 
   
      break;
    case 2:
      // Some example procedures showing how to display to the pixels:
      colorWipe(strip.Color(255, 0, 0), 50); // Red
    16d6:	0e 94 e4 04 	call	0x9c8	; 0x9c8 <colorWipe(unsigned long, unsigned char)>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:117
      colorWipe(strip.Color(0, 0, 0), 50); // Red
    16da:	42 e3       	ldi	r20, 0x32	; 50
    16dc:	60 e0       	ldi	r22, 0x00	; 0
    16de:	70 e0       	ldi	r23, 0x00	; 0
    16e0:	cb 01       	movw	r24, r22
    16e2:	0e 94 e4 04 	call	0x9c8	; 0x9c8 <colorWipe(unsigned long, unsigned char)>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:175
      //colorWipe(strip.Color(0, 0, 0), 0); // black
      strip.show();
      break;
  } // end switch stmt

  nextState = false;
    16e6:	10 92 80 39 	sts	0x3980, r1	; 0x803980 <nextState>
millis():
  //return timer_overflow_count; //for debugging timekeeping issues where these variables are out of scope from the sketch
  unsigned long m;

  // disable interrupts while we read timer0_millis or we might get an
  // inconsistent value (e.g. in the middle of a write to timer0_millis)
  uint8_t status = SREG;
    16ea:	2f b7       	in	r18, 0x3f	; 63
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:176
  cli();
    16ec:	f8 94       	cli
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:188
  m = (m << 16);
  m += RTC.CNT;
  //now correct for there being 1000ms to the second instead of 1024
  m = m - (m >> 6) - (m >> 7);
  #else
  m = timer_millis;
    16ee:	80 91 78 38 	lds	r24, 0x3878	; 0x803878 <timer_millis>
    16f2:	90 91 79 38 	lds	r25, 0x3879	; 0x803879 <timer_millis+0x1>
    16f6:	a0 91 7a 38 	lds	r26, 0x387A	; 0x80387a <timer_millis+0x2>
    16fa:	b0 91 7b 38 	lds	r27, 0x387B	; 0x80387b <timer_millis+0x3>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:189
  SREG = status;
    16fe:	2f bf       	out	0x3f, r18	; 63
setI2CreadOnly():
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:211
#define READ_INTERVAL 100
/**
 * Read in statuses from inputs and load them into I2CBuffer
 */
void setI2CreadOnly(){
   if (millis() - lastReadTime > READ_INTERVAL ){
    1700:	40 91 7c 39 	lds	r20, 0x397C	; 0x80397c <lastReadTime>
    1704:	50 91 7d 39 	lds	r21, 0x397D	; 0x80397d <lastReadTime+0x1>
    1708:	60 91 7e 39 	lds	r22, 0x397E	; 0x80397e <lastReadTime+0x2>
    170c:	70 91 7f 39 	lds	r23, 0x397F	; 0x80397f <lastReadTime+0x3>
    1710:	84 1b       	sub	r24, r20
    1712:	95 0b       	sbc	r25, r21
    1714:	a6 0b       	sbc	r26, r22
    1716:	b7 0b       	sbc	r27, r23
    1718:	85 36       	cpi	r24, 0x65	; 101
    171a:	91 05       	cpc	r25, r1
    171c:	a1 05       	cpc	r26, r1
    171e:	b1 05       	cpc	r27, r1
    1720:	d0 f1       	brcs	.+116    	; 0x1796 <main+0x4ac>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:213
     // bufferI2C[80] = pulseIn(FAN_TACH, HIGH, 100) ;
      bufferI2C[0x51] = digitalRead(TPU_PGOOD);
    1722:	89 e0       	ldi	r24, 0x09	; 9
    1724:	0e 94 2f 05 	call	0xa5e	; 0xa5e <digitalRead>
    1728:	80 93 cd 38 	sts	0x38CD, r24	; 0x8038cd <bufferI2C+0x51>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:214
      bufferI2C[0x52] = digitalRead(TPU_PMIC_EN);
    172c:	82 e0       	ldi	r24, 0x02	; 2
    172e:	0e 94 2f 05 	call	0xa5e	; 0xa5e <digitalRead>
    1732:	80 93 ce 38 	sts	0x38CE, r24	; 0x8038ce <bufferI2C+0x52>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:216
      //bufferI2C[0x53] = digitalRead(TPU_INTR);
      bufferI2C[0x54] = digitalRead(TPU_RST_L);
    1736:	88 e0       	ldi	r24, 0x08	; 8
    1738:	0e 94 2f 05 	call	0xa5e	; 0xa5e <digitalRead>
    173c:	80 93 d0 38 	sts	0x38D0, r24	; 0x8038d0 <bufferI2C+0x54>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:217
      bufferI2C[0x60] = 0xFF;    
    1740:	e0 92 dc 38 	sts	0x38DC, r14	; 0x8038dc <bufferI2C+0x60>
millis():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:175
  //return timer_overflow_count; //for debugging timekeeping issues where these variables are out of scope from the sketch
  unsigned long m;

  // disable interrupts while we read timer0_millis or we might get an
  // inconsistent value (e.g. in the middle of a write to timer0_millis)
  uint8_t status = SREG;
    1744:	2f b7       	in	r18, 0x3f	; 63
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:176
  cli();
    1746:	f8 94       	cli
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:188
  m = (m << 16);
  m += RTC.CNT;
  //now correct for there being 1000ms to the second instead of 1024
  m = m - (m >> 6) - (m >> 7);
  #else
  m = timer_millis;
    1748:	80 91 78 38 	lds	r24, 0x3878	; 0x803878 <timer_millis>
    174c:	90 91 79 38 	lds	r25, 0x3879	; 0x803879 <timer_millis+0x1>
    1750:	a0 91 7a 38 	lds	r26, 0x387A	; 0x80387a <timer_millis+0x2>
    1754:	b0 91 7b 38 	lds	r27, 0x387B	; 0x80387b <timer_millis+0x3>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:189
  SREG = status;
    1758:	2f bf       	out	0x3f, r18	; 63
setI2CreadOnly():
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:220
      
      long timestampNow = millis();  
      bufferI2C[0xF0] = timestampNow & 0xFF;
    175a:	80 93 6c 39 	sts	0x396C, r24	; 0x80396c <bufferI2C+0xf0>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:221
      bufferI2C[0xF1] = (timestampNow >> 8) & 0xFF;
    175e:	90 93 6d 39 	sts	0x396D, r25	; 0x80396d <bufferI2C+0xf1>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:222
      bufferI2C[0xF2] = (timestampNow >> 16) & 0xFF;
    1762:	a0 93 6e 39 	sts	0x396E, r26	; 0x80396e <bufferI2C+0xf2>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:223
      bufferI2C[0xF3] = (timestampNow >> 24) & 0xFF;
    1766:	b0 93 6f 39 	sts	0x396F, r27	; 0x80396f <bufferI2C+0xf3>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:224
      bufferI2C[0xF4] = 0xF4; 
    176a:	e4 ef       	ldi	r30, 0xF4	; 244
    176c:	e0 93 70 39 	sts	0x3970, r30	; 0x803970 <bufferI2C+0xf4>
millis():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:175
  //return timer_overflow_count; //for debugging timekeeping issues where these variables are out of scope from the sketch
  unsigned long m;

  // disable interrupts while we read timer0_millis or we might get an
  // inconsistent value (e.g. in the middle of a write to timer0_millis)
  uint8_t status = SREG;
    1770:	2f b7       	in	r18, 0x3f	; 63
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:176
  cli();
    1772:	f8 94       	cli
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:188
  m = (m << 16);
  m += RTC.CNT;
  //now correct for there being 1000ms to the second instead of 1024
  m = m - (m >> 6) - (m >> 7);
  #else
  m = timer_millis;
    1774:	80 91 78 38 	lds	r24, 0x3878	; 0x803878 <timer_millis>
    1778:	90 91 79 38 	lds	r25, 0x3879	; 0x803879 <timer_millis+0x1>
    177c:	a0 91 7a 38 	lds	r26, 0x387A	; 0x80387a <timer_millis+0x2>
    1780:	b0 91 7b 38 	lds	r27, 0x387B	; 0x80387b <timer_millis+0x3>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/wiring.c:189
  SREG = status;
    1784:	2f bf       	out	0x3f, r18	; 63
setI2CreadOnly():
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:228

      
      
      lastReadTime = millis();
    1786:	80 93 7c 39 	sts	0x397C, r24	; 0x80397c <lastReadTime>
    178a:	90 93 7d 39 	sts	0x397D, r25	; 0x80397d <lastReadTime+0x1>
    178e:	a0 93 7e 39 	sts	0x397E, r26	; 0x80397e <lastReadTime+0x2>
    1792:	b0 93 7f 39 	sts	0x397F, r27	; 0x80397f <lastReadTime+0x3>
serialEventRun():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:66
    1796:	81 14       	cp	r8, r1
    1798:	91 04       	cpc	r9, r1
    179a:	09 f4       	brne	.+2      	; 0x179e <main+0x4b4>
    179c:	fc ce       	rjmp	.-520    	; 0x1596 <main+0x2ac>
    179e:	0e 94 b1 02 	call	0x562	; 0x562 <Serial0_available()>
    17a2:	88 23       	and	r24, r24
    17a4:	09 f4       	brne	.+2      	; 0x17a8 <main+0x4be>
    17a6:	f7 ce       	rjmp	.-530    	; 0x1596 <main+0x2ac>
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\cores\megatinycore/UART.cpp:67
    serialEvent();
    17a8:	0e 94 00 00 	call	0	; 0x0 <__TEXT_REGION_ORIGIN__>
    17ac:	f4 ce       	rjmp	.-536    	; 0x1596 <main+0x2ac>
loop():
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:120
      // Some example procedures showing how to display to the pixels:
      colorWipe(strip.Color(255, 0, 0), 50); // Red
      colorWipe(strip.Color(0, 0, 0), 50); // Red
      break;
    case 3:
      colorWipe(strip.Color(0, 255, 0), 50); // Green
    17ae:	42 e3       	ldi	r20, 0x32	; 50
    17b0:	60 e0       	ldi	r22, 0x00	; 0
    17b2:	7f ef       	ldi	r23, 0xFF	; 255
    17b4:	80 e0       	ldi	r24, 0x00	; 0
    17b6:	90 e0       	ldi	r25, 0x00	; 0
    17b8:	8e cf       	rjmp	.-228    	; 0x16d6 <main+0x3ec>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:101
  
  readNumBoots();
}

void loop() {
  switch(state){
    17ba:	5a e0       	ldi	r21, 0x0A	; 10
    17bc:	a5 2e       	mov	r10, r21
    17be:	b1 2c       	mov	r11, r1
theaterChase():
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:372
  }
}
*/
//Theatre-style crawling lights.
void theaterChase(uint32_t c, uint8_t wait) {
  for (int j=0; j<10 && !nextState; j++) {  //do 10 cycles of chasing
    17c0:	80 91 80 39 	lds	r24, 0x3980	; 0x803980 <nextState>
    17c4:	81 11       	cpse	r24, r1
    17c6:	8f cf       	rjmp	.-226    	; 0x16e6 <main+0x3fc>
main():
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:373
    for (int q=0; q < 3 && !nextState; q++) {
    17c8:	10 e0       	ldi	r17, 0x00	; 0
    17ca:	00 e0       	ldi	r16, 0x00	; 0
theaterChase():
    17cc:	80 91 80 39 	lds	r24, 0x3980	; 0x803980 <nextState>
    17d0:	88 23       	and	r24, r24
    17d2:	29 f0       	breq	.+10     	; 0x17de <main+0x4f4>
    17d4:	81 e0       	ldi	r24, 0x01	; 1
    17d6:	a8 1a       	sub	r10, r24
    17d8:	b1 08       	sbc	r11, r1
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:372
  }
}
*/
//Theatre-style crawling lights.
void theaterChase(uint32_t c, uint8_t wait) {
  for (int j=0; j<10 && !nextState; j++) {  //do 10 cycles of chasing
    17da:	91 f7       	brne	.-28     	; 0x17c0 <main+0x4d6>
    17dc:	84 cf       	rjmp	.-248    	; 0x16e6 <main+0x3fc>
main():
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:374
    for (int q=0; q < 3 && !nextState; q++) {
      for (int i=0; i < strip.numPixels(); i=i+3) {
    17de:	d1 2c       	mov	r13, r1
    17e0:	c1 2c       	mov	r12, r1
theaterChase():
    17e2:	80 91 4d 3a 	lds	r24, 0x3A4D	; 0x803a4d <strip>
    17e6:	90 91 4e 3a 	lds	r25, 0x3A4E	; 0x803a4e <strip+0x1>
    17ea:	c8 16       	cp	r12, r24
    17ec:	d9 06       	cpc	r13, r25
    17ee:	68 f4       	brcc	.+26     	; 0x180a <main+0x520>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:375
        strip.setPixelColor(i+q, c);    //turn every third pixel on
    17f0:	4f e7       	ldi	r20, 0x7F	; 127
    17f2:	5f e7       	ldi	r21, 0x7F	; 127
    17f4:	6f e7       	ldi	r22, 0x7F	; 127
    17f6:	70 e0       	ldi	r23, 0x00	; 0
    17f8:	c8 01       	movw	r24, r16
    17fa:	8c 0d       	add	r24, r12
    17fc:	9d 1d       	adc	r25, r13
    17fe:	0e 94 5e 01 	call	0x2bc	; 0x2bc <tinyNeoPixel::setPixelColor(unsigned int, unsigned long) [clone .constprop.6]>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:374
*/
//Theatre-style crawling lights.
void theaterChase(uint32_t c, uint8_t wait) {
  for (int j=0; j<10 && !nextState; j++) {  //do 10 cycles of chasing
    for (int q=0; q < 3 && !nextState; q++) {
      for (int i=0; i < strip.numPixels(); i=i+3) {
    1802:	93 e0       	ldi	r25, 0x03	; 3
    1804:	c9 0e       	add	r12, r25
    1806:	d1 1c       	adc	r13, r1
    1808:	ec cf       	rjmp	.-40     	; 0x17e2 <main+0x4f8>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:377
        strip.setPixelColor(i+q, c);    //turn every third pixel on
      }
      strip.show();
    180a:	0e 94 53 03 	call	0x6a6	; 0x6a6 <tinyNeoPixel::show() [clone .constprop.18]>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:379

      delay(wait);
    180e:	68 ec       	ldi	r22, 0xC8	; 200
    1810:	70 e0       	ldi	r23, 0x00	; 0
    1812:	80 e0       	ldi	r24, 0x00	; 0
    1814:	90 e0       	ldi	r25, 0x00	; 0
    1816:	0e 94 d9 03 	call	0x7b2	; 0x7b2 <delay>
main():
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:381

      for (int i=0; i < strip.numPixels() && !nextState; i=i+3) {
    181a:	d1 2c       	mov	r13, r1
    181c:	c1 2c       	mov	r12, r1
theaterChase():
    181e:	80 91 4d 3a 	lds	r24, 0x3A4D	; 0x803a4d <strip>
    1822:	90 91 4e 3a 	lds	r25, 0x3A4E	; 0x803a4e <strip+0x1>
    1826:	c8 16       	cp	r12, r24
    1828:	d9 06       	cpc	r13, r25
    182a:	20 f4       	brcc	.+8      	; 0x1834 <main+0x54a>
    182c:	80 91 80 39 	lds	r24, 0x3980	; 0x803980 <nextState>
    1830:	88 23       	and	r24, r24
    1832:	31 f0       	breq	.+12     	; 0x1840 <main+0x556>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:373
}
*/
//Theatre-style crawling lights.
void theaterChase(uint32_t c, uint8_t wait) {
  for (int j=0; j<10 && !nextState; j++) {  //do 10 cycles of chasing
    for (int q=0; q < 3 && !nextState; q++) {
    1834:	0f 5f       	subi	r16, 0xFF	; 255
    1836:	1f 4f       	sbci	r17, 0xFF	; 255
    1838:	03 30       	cpi	r16, 0x03	; 3
    183a:	11 05       	cpc	r17, r1
    183c:	39 f6       	brne	.-114    	; 0x17cc <main+0x4e2>
    183e:	ca cf       	rjmp	.-108    	; 0x17d4 <main+0x4ea>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:382
      strip.show();

      delay(wait);

      for (int i=0; i < strip.numPixels() && !nextState; i=i+3) {
        strip.setPixelColor(i+q, 0);        //turn every third pixel off
    1840:	40 e0       	ldi	r20, 0x00	; 0
    1842:	50 e0       	ldi	r21, 0x00	; 0
    1844:	ba 01       	movw	r22, r20
    1846:	c8 01       	movw	r24, r16
    1848:	8c 0d       	add	r24, r12
    184a:	9d 1d       	adc	r25, r13
    184c:	0e 94 5e 01 	call	0x2bc	; 0x2bc <tinyNeoPixel::setPixelColor(unsigned int, unsigned long) [clone .constprop.6]>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:381
      }
      strip.show();

      delay(wait);

      for (int i=0; i < strip.numPixels() && !nextState; i=i+3) {
    1850:	e3 e0       	ldi	r30, 0x03	; 3
    1852:	ce 0e       	add	r12, r30
    1854:	d1 1c       	adc	r13, r1
    1856:	e3 cf       	rjmp	.-58     	; 0x181e <main+0x534>
Wheel():
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:411
*/
// Input a value 0 to 255 to get a color value.
// The colours are a transition r - g - b - back to r.
uint32_t Wheel(byte WheelPos) {
  WheelPos = 255 - WheelPos;
  if(WheelPos < 85) {
    1858:	82 2d       	mov	r24, r2
    185a:	87 0d       	add	r24, r7
    185c:	85 35       	cpi	r24, 0x55	; 85
    185e:	a0 f4       	brcc	.+40     	; 0x1888 <main+0x59e>
_ZN12tinyNeoPixel5ColorEhhh():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.h:263
    1860:	43 2d       	mov	r20, r3
    1862:	41 0f       	add	r20, r17
    1864:	50 e0       	ldi	r21, 0x00	; 0
    1866:	70 e0       	ldi	r23, 0x00	; 0
    1868:	60 e0       	ldi	r22, 0x00	; 0
    186a:	ba 01       	movw	r22, r20
    186c:	55 27       	eor	r21, r21
    186e:	44 27       	eor	r20, r20
    1870:	8b a1       	ldd	r24, Y+35	; 0x23
    1872:	81 1b       	sub	r24, r17
    1874:	48 2b       	or	r20, r24
rainbow():
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:350
void rainbow(uint8_t wait) {
  uint16_t i, j;

  for(j=0; j<256 && !nextState; j++) {
    for(i=0; i<strip.numPixels() && !nextState; i++) {
      strip.setPixelColor(i, Wheel((i+j) & 255));
    1876:	c6 01       	movw	r24, r12
    1878:	0e 94 5e 01 	call	0x2bc	; 0x2bc <tinyNeoPixel::setPixelColor(unsigned int, unsigned long) [clone .constprop.6]>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:349

void rainbow(uint8_t wait) {
  uint16_t i, j;

  for(j=0; j<256 && !nextState; j++) {
    for(i=0; i<strip.numPixels() && !nextState; i++) {
    187c:	8f ef       	ldi	r24, 0xFF	; 255
    187e:	c8 1a       	sub	r12, r24
    1880:	d8 0a       	sbc	r13, r24
    1882:	1d 5f       	subi	r17, 0xFD	; 253
    1884:	7a 94       	dec	r7
    1886:	c2 ce       	rjmp	.-636    	; 0x160c <main+0x322>
Wheel():
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:414
uint32_t Wheel(byte WheelPos) {
  WheelPos = 255 - WheelPos;
  if(WheelPos < 85) {
    return strip.Color(255 - WheelPos * 3, 0, WheelPos * 3);
  }
  if(WheelPos < 170) {
    1888:	8a 3a       	cpi	r24, 0xAA	; 170
    188a:	60 f4       	brcc	.+24     	; 0x18a4 <main+0x5ba>
_ZN12tinyNeoPixel5ColorEhhh():
C:\Users\kevin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.2.4\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.h:263
    188c:	45 2d       	mov	r20, r5
    188e:	41 1b       	sub	r20, r17
    1890:	50 e0       	ldi	r21, 0x00	; 0
    1892:	70 e0       	ldi	r23, 0x00	; 0
    1894:	60 e0       	ldi	r22, 0x00	; 0
    1896:	76 2f       	mov	r23, r22
    1898:	65 2f       	mov	r22, r21
    189a:	54 2f       	mov	r21, r20
    189c:	44 27       	eor	r20, r20
    189e:	84 2d       	mov	r24, r4
    18a0:	81 0f       	add	r24, r17
    18a2:	e8 cf       	rjmp	.-48     	; 0x1874 <main+0x58a>
    18a4:	4f 2d       	mov	r20, r15
    18a6:	41 0f       	add	r20, r17
    18a8:	50 e0       	ldi	r21, 0x00	; 0
    18aa:	70 e0       	ldi	r23, 0x00	; 0
    18ac:	60 e0       	ldi	r22, 0x00	; 0
    18ae:	76 2f       	mov	r23, r22
    18b0:	65 2f       	mov	r22, r21
    18b2:	54 2f       	mov	r21, r20
    18b4:	44 27       	eor	r20, r20
    18b6:	8a a1       	ldd	r24, Y+34	; 0x22
    18b8:	81 1b       	sub	r24, r17
    18ba:	68 2b       	or	r22, r24
    18bc:	dc cf       	rjmp	.-72     	; 0x1876 <main+0x58c>
set_pattern():
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:426


void set_pattern() {
  byte pattern_num = bufferI2C[0];
  byte addrStart   = bufferI2C[1];
  pattern[pattern_num][addrStart * 3] = bufferI2C[2];
    18be:	e0 91 7c 38 	lds	r30, 0x387C	; 0x80387c <bufferI2C>
    18c2:	80 91 7d 38 	lds	r24, 0x387D	; 0x80387d <bufferI2C+0x1>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:428
  pattern[pattern_num][addrStart * 3] = bufferI2C[3];
  pattern[pattern_num][addrStart * 3] = bufferI2C[4];
    18c6:	6e 9e       	mul	r6, r30
    18c8:	f0 01       	movw	r30, r0
    18ca:	11 24       	eor	r1, r1
    18cc:	e4 59       	subi	r30, 0x94	; 148
    18ce:	f7 4c       	sbci	r31, 0xC7	; 199
    18d0:	93 e0       	ldi	r25, 0x03	; 3
    18d2:	89 9f       	mul	r24, r25
    18d4:	e0 0d       	add	r30, r0
    18d6:	f1 1d       	adc	r31, r1
    18d8:	11 24       	eor	r1, r1
    18da:	80 91 80 38 	lds	r24, 0x3880	; 0x803880 <bufferI2C+0x4>
    18de:	80 83       	st	Z, r24
    18e0:	02 cf       	rjmp	.-508    	; 0x16e6 <main+0x3fc>
fill_pattern():
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:434
}

void fill_pattern() {
  byte pattern_num = bufferI2C[0];
  for (byte i=0; i < NUMPIXELS; i++) {
    pattern[pattern_num][1 + i * 3] = bufferI2C[1];
    18e2:	30 91 7d 38 	lds	r19, 0x387D	; 0x80387d <bufferI2C+0x1>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:435
    pattern[pattern_num][2 + i * 3] = bufferI2C[2];
    18e6:	20 91 7e 38 	lds	r18, 0x387E	; 0x80387e <bufferI2C+0x2>
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:436
    pattern[pattern_num][3 + i * 3] = bufferI2C[3];
    18ea:	90 91 7f 38 	lds	r25, 0x387F	; 0x80387f <bufferI2C+0x3>
    18ee:	e0 91 7c 38 	lds	r30, 0x387C	; 0x80387c <bufferI2C>
    18f2:	e6 9d       	mul	r30, r6
    18f4:	f0 01       	movw	r30, r0
    18f6:	11 24       	eor	r1, r1
    18f8:	e4 59       	subi	r30, 0x94	; 148
    18fa:	f7 4c       	sbci	r31, 0xC7	; 199
    18fc:	8c e0       	ldi	r24, 0x0C	; 12
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:434
}

void fill_pattern() {
  byte pattern_num = bufferI2C[0];
  for (byte i=0; i < NUMPIXELS; i++) {
    pattern[pattern_num][1 + i * 3] = bufferI2C[1];
    18fe:	31 83       	std	Z+1, r19	; 0x01
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:435
    pattern[pattern_num][2 + i * 3] = bufferI2C[2];
    1900:	22 83       	std	Z+2, r18	; 0x02
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:436
    pattern[pattern_num][3 + i * 3] = bufferI2C[3];
    1902:	93 83       	std	Z+3, r25	; 0x03
    1904:	81 50       	subi	r24, 0x01	; 1
    1906:	33 96       	adiw	r30, 0x03	; 3
C:\Dropbox\Crashspace\Mycroft\programming\mark2_attiny1614.ino/mark2_attiny1614.ino.ino:433
  pattern[pattern_num][addrStart * 3] = bufferI2C[4];
}

void fill_pattern() {
  byte pattern_num = bufferI2C[0];
  for (byte i=0; i < NUMPIXELS; i++) {
    1908:	81 11       	cpse	r24, r1
    190a:	f9 cf       	rjmp	.-14     	; 0x18fe <main+0x614>
    190c:	ec ce       	rjmp	.-552    	; 0x16e6 <main+0x3fc>

0000190e <eeprom_read_byte>:
eeprom_read_byte():
/home/toolsbuild/workspace/avr8-devices-pack/src/avr-libc/avr/lib/avrxmega3/attiny1614/../../../../libc/misc/eerd_byte.S:51
    190e:	03 d0       	rcall	.+6      	; 0x1916 <eeprom_mapen>
/home/toolsbuild/workspace/avr8-devices-pack/src/avr-libc/avr/lib/avrxmega3/attiny1614/../../../../libc/misc/eerd_byte.S:52
    1910:	80 81       	ld	r24, Z
/home/toolsbuild/workspace/avr8-devices-pack/src/avr-libc/avr/lib/avrxmega3/attiny1614/../../../../libc/misc/eerd_byte.S:53
    1912:	99 27       	eor	r25, r25
/home/toolsbuild/workspace/avr8-devices-pack/src/avr-libc/avr/lib/avrxmega3/attiny1614/../../../../libc/misc/eerd_byte.S:54
    1914:	08 95       	ret

00001916 <eeprom_mapen>:
/home/toolsbuild/workspace/avr8-devices-pack/src/avr-libc/avr/lib/avrxmega3/attiny1614/../../../../libc/misc/eerd_byte.S:83
    1916:	fc 01       	movw	r30, r24
/home/toolsbuild/workspace/avr8-devices-pack/src/avr-libc/avr/lib/avrxmega3/attiny1614/../../../../libc/misc/eerd_byte.S:84
    1918:	e0 50       	subi	r30, 0x00	; 0
/home/toolsbuild/workspace/avr8-devices-pack/src/avr-libc/avr/lib/avrxmega3/attiny1614/../../../../libc/misc/eerd_byte.S:85
    191a:	fc 4e       	sbci	r31, 0xEC	; 236
/home/toolsbuild/workspace/avr8-devices-pack/src/avr-libc/avr/lib/avrxmega3/attiny1614/../../../../libc/misc/eerd_byte.S:87
    191c:	08 95       	ret

0000191e <eeprom_write_byte>:
eeprom_write_byte():
/home/toolsbuild/workspace/avr8-devices-pack/src/avr-libc/avr/lib/avrxmega3/attiny1614/../../../../libc/misc/eewr_byte.S:42
    191e:	26 2f       	mov	r18, r22

00001920 <eeprom_write_r18>:
/home/toolsbuild/workspace/avr8-devices-pack/src/avr-libc/avr/lib/avrxmega3/attiny1614/../../../../libc/misc/eewr_byte.S:66
    1920:	af 93       	push	r26
/home/toolsbuild/workspace/avr8-devices-pack/src/avr-libc/avr/lib/avrxmega3/attiny1614/../../../../libc/misc/eewr_byte.S:67
    1922:	bf 93       	push	r27
/home/toolsbuild/workspace/avr8-devices-pack/src/avr-libc/avr/lib/avrxmega3/attiny1614/../../../../libc/misc/eewr_byte.S:71
    1924:	e0 e0       	ldi	r30, 0x00	; 0
/home/toolsbuild/workspace/avr8-devices-pack/src/avr-libc/avr/lib/avrxmega3/attiny1614/../../../../libc/misc/eewr_byte.S:72
    1926:	f0 e1       	ldi	r31, 0x10	; 16
/home/toolsbuild/workspace/avr8-devices-pack/src/avr-libc/avr/lib/avrxmega3/attiny1614/../../../../libc/misc/eewr_byte.S:75
    1928:	32 81       	ldd	r19, Z+2	; 0x02
/home/toolsbuild/workspace/avr8-devices-pack/src/avr-libc/avr/lib/avrxmega3/attiny1614/../../../../libc/misc/eewr_byte.S:76
    192a:	31 fd       	sbrc	r19, 1
/home/toolsbuild/workspace/avr8-devices-pack/src/avr-libc/avr/lib/avrxmega3/attiny1614/../../../../libc/misc/eewr_byte.S:77
    192c:	fd cf       	rjmp	.-6      	; 0x1928 <eeprom_write_r18+0x8>
/home/toolsbuild/workspace/avr8-devices-pack/src/avr-libc/avr/lib/avrxmega3/attiny1614/../../../../libc/misc/eewr_byte.S:128
    192e:	dc 01       	movw	r26, r24
/home/toolsbuild/workspace/avr8-devices-pack/src/avr-libc/avr/lib/avrxmega3/attiny1614/../../../../libc/misc/eewr_byte.S:129
    1930:	a0 50       	subi	r26, 0x00	; 0
/home/toolsbuild/workspace/avr8-devices-pack/src/avr-libc/avr/lib/avrxmega3/attiny1614/../../../../libc/misc/eewr_byte.S:130
    1932:	bc 4e       	sbci	r27, 0xEC	; 236
/home/toolsbuild/workspace/avr8-devices-pack/src/avr-libc/avr/lib/avrxmega3/attiny1614/../../../../libc/misc/eewr_byte.S:131
    1934:	2c 93       	st	X, r18
/home/toolsbuild/workspace/avr8-devices-pack/src/avr-libc/avr/lib/avrxmega3/attiny1614/../../../../libc/misc/eewr_byte.S:136
    1936:	2d e9       	ldi	r18, 0x9D	; 157
/home/toolsbuild/workspace/avr8-devices-pack/src/avr-libc/avr/lib/avrxmega3/attiny1614/../../../../libc/misc/eewr_byte.S:137
    1938:	24 bf       	out	0x34, r18	; 52
/home/toolsbuild/workspace/avr8-devices-pack/src/avr-libc/avr/lib/avrxmega3/attiny1614/../../../../libc/misc/eewr_byte.S:138
    193a:	23 e0       	ldi	r18, 0x03	; 3
/home/toolsbuild/workspace/avr8-devices-pack/src/avr-libc/avr/lib/avrxmega3/attiny1614/../../../../libc/misc/eewr_byte.S:139
    193c:	20 83       	st	Z, r18
/home/toolsbuild/workspace/avr8-devices-pack/src/avr-libc/avr/lib/avrxmega3/attiny1614/../../../../libc/misc/eewr_byte.S:150
    193e:	01 96       	adiw	r24, 0x01	; 1
/home/toolsbuild/workspace/avr8-devices-pack/src/avr-libc/avr/lib/avrxmega3/attiny1614/../../../../libc/misc/eewr_byte.S:154
    1940:	bf 91       	pop	r27
/home/toolsbuild/workspace/avr8-devices-pack/src/avr-libc/avr/lib/avrxmega3/attiny1614/../../../../libc/misc/eewr_byte.S:155
    1942:	af 91       	pop	r26
/home/toolsbuild/workspace/avr8-devices-pack/src/avr-libc/avr/lib/avrxmega3/attiny1614/../../../../libc/misc/eewr_byte.S:158
    1944:	08 95       	ret

00001946 <__udivmodhi4>:
__udivmodhi4():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1408
    1946:	aa 1b       	sub	r26, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1409
    1948:	bb 1b       	sub	r27, r27
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1410
    194a:	51 e1       	ldi	r21, 0x11	; 17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1411
    194c:	07 c0       	rjmp	.+14     	; 0x195c <__udivmodhi4_ep>

0000194e <__udivmodhi4_loop>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1413
    194e:	aa 1f       	adc	r26, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1414
    1950:	bb 1f       	adc	r27, r27
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1415
    1952:	a6 17       	cp	r26, r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1416
    1954:	b7 07       	cpc	r27, r23
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1417
    1956:	10 f0       	brcs	.+4      	; 0x195c <__udivmodhi4_ep>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1418
    1958:	a6 1b       	sub	r26, r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1419
    195a:	b7 0b       	sbc	r27, r23

0000195c <__udivmodhi4_ep>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1421
    195c:	88 1f       	adc	r24, r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1422
    195e:	99 1f       	adc	r25, r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1423
    1960:	5a 95       	dec	r21
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1424
    1962:	a9 f7       	brne	.-22     	; 0x194e <__udivmodhi4_loop>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1425
    1964:	80 95       	com	r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1426
    1966:	90 95       	com	r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1428
    1968:	bc 01       	movw	r22, r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1430
    196a:	cd 01       	movw	r24, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1432
    196c:	08 95       	ret

0000196e <__udivmodsi4>:
__udivmodsi4():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1638
    196e:	a1 e2       	ldi	r26, 0x21	; 33
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1639
    1970:	1a 2e       	mov	r1, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1640
    1972:	aa 1b       	sub	r26, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1641
    1974:	bb 1b       	sub	r27, r27
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1642
    1976:	fd 01       	movw	r30, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1644
    1978:	0d c0       	rjmp	.+26     	; 0x1994 <__udivmodsi4_ep>

0000197a <__udivmodsi4_loop>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1646
    197a:	aa 1f       	adc	r26, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1647
    197c:	bb 1f       	adc	r27, r27
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1648
    197e:	ee 1f       	adc	r30, r30
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1649
    1980:	ff 1f       	adc	r31, r31
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1650
    1982:	a2 17       	cp	r26, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1651
    1984:	b3 07       	cpc	r27, r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1652
    1986:	e4 07       	cpc	r30, r20
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1653
    1988:	f5 07       	cpc	r31, r21
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1654
    198a:	20 f0       	brcs	.+8      	; 0x1994 <__udivmodsi4_ep>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1655
    198c:	a2 1b       	sub	r26, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1656
    198e:	b3 0b       	sbc	r27, r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1657
    1990:	e4 0b       	sbc	r30, r20
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1658
    1992:	f5 0b       	sbc	r31, r21

00001994 <__udivmodsi4_ep>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1660
    1994:	66 1f       	adc	r22, r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1661
    1996:	77 1f       	adc	r23, r23
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1662
    1998:	88 1f       	adc	r24, r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1663
    199a:	99 1f       	adc	r25, r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1664
    199c:	1a 94       	dec	r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1665
    199e:	69 f7       	brne	.-38     	; 0x197a <__udivmodsi4_loop>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1667
    19a0:	60 95       	com	r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1668
    19a2:	70 95       	com	r23
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1669
    19a4:	80 95       	com	r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1670
    19a6:	90 95       	com	r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1672
    19a8:	9b 01       	movw	r18, r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1674
    19aa:	ac 01       	movw	r20, r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1676
    19ac:	bd 01       	movw	r22, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1678
    19ae:	cf 01       	movw	r24, r30
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1680
    19b0:	08 95       	ret

000019b2 <__muluhisi3>:
__muluhisi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:626
    19b2:	0e 94 f2 0c 	call	0x19e4	; 0x19e4 <__umulhisi3>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:627
    19b6:	a5 9f       	mul	r26, r21
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:628
    19b8:	90 0d       	add	r25, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:629
    19ba:	b4 9f       	mul	r27, r20
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:630
    19bc:	90 0d       	add	r25, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:631
    19be:	a4 9f       	mul	r26, r20
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:632
    19c0:	80 0d       	add	r24, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:633
    19c2:	91 1d       	adc	r25, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:634
    19c4:	11 24       	eor	r1, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:635
    19c6:	08 95       	ret

000019c8 <__mulshisi3>:
__mulshisi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:603
    19c8:	b7 ff       	sbrs	r27, 7
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:605
    19ca:	0c 94 d9 0c 	jmp	0x19b2	; 0x19b2 <__muluhisi3>

000019ce <__mulohisi3>:
__mulohisi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:613
    19ce:	0e 94 d9 0c 	call	0x19b2	; 0x19b2 <__muluhisi3>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:615
    19d2:	82 1b       	sub	r24, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:616
    19d4:	93 0b       	sbc	r25, r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:617
    19d6:	08 95       	ret

000019d8 <__tablejump2__>:
__tablejump2__():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2296
    19d8:	ee 0f       	add	r30, r30
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2297
    19da:	ff 1f       	adc	r31, r31
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2328
    19dc:	05 90       	lpm	r0, Z+
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2329
    19de:	f4 91       	lpm	r31, Z
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2330
    19e0:	e0 2d       	mov	r30, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2331
    19e2:	09 94       	ijmp

000019e4 <__umulhisi3>:
__umulhisi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:564
    19e4:	a2 9f       	mul	r26, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:565
    19e6:	b0 01       	movw	r22, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:566
    19e8:	b3 9f       	mul	r27, r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:567
    19ea:	c0 01       	movw	r24, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:568
    19ec:	a3 9f       	mul	r26, r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:573
    19ee:	70 0d       	add	r23, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:574
    19f0:	81 1d       	adc	r24, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:575
    19f2:	11 24       	eor	r1, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:576
    19f4:	91 1d       	adc	r25, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:580
    19f6:	b2 9f       	mul	r27, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:581
    19f8:	70 0d       	add	r23, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:582
    19fa:	81 1d       	adc	r24, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:583
    19fc:	11 24       	eor	r1, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:584
    19fe:	91 1d       	adc	r25, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:585
    1a00:	08 95       	ret

00001a02 <_exit>:
exit():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2278
    1a02:	f8 94       	cli

00001a04 <__stop_program>:
__stop_program():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2280
    1a04:	ff cf       	rjmp	.-2      	; 0x1a04 <__stop_program>
